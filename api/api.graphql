### This file was generated by Nexus Schema
### Do not make changes to this file directly


input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

type Employee {
  createdAt: DateTime!
  earning: Float!
  hiringType: HiringType!
  id: String!
  name: String!
  status: EmployeeStatus!
  updateAt: DateTime!
}

input EmployeeCreateInput {
  createdAt: DateTime
  earning: Float!
  hiringType: HiringType!
  id: String
  name: String!
  Payroll: PayrollCreateManyWithoutEmployeeInput
  status: EmployeeStatus!
  updateAt: DateTime
  WorkingHistory: WorkingHistoryCreateManyWithoutEmployeeInput
}

input EmployeeOrderByInput {
  createdAt: SortOrder
  earning: SortOrder
  hiringType: SortOrder
  id: SortOrder
  name: SortOrder
  status: SortOrder
  updateAt: SortOrder
}

enum EmployeeStatus {
  ACTIVE
  DELETED
}

input EmployeeUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  earning: FloatFieldUpdateOperationsInput
  hiringType: HiringType
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  Payroll: PayrollUpdateManyWithoutEmployeeInput
  status: EmployeeStatus
  updateAt: DateTimeFieldUpdateOperationsInput
  WorkingHistory: WorkingHistoryUpdateManyWithoutEmployeeInput
}

input EmployeeWhereInput {
  AND: [EmployeeWhereInput!]
  createdAt: DateTimeFilter
  earning: FloatFilter
  hiringType: HiringType
  id: StringFilter
  name: StringFilter
  NOT: [EmployeeWhereInput!]
  OR: [EmployeeWhereInput!]
  Payroll: PayrollListRelationFilter
  status: EmployeeStatus
  updateAt: DateTimeFilter
  WorkingHistory: WorkingHistoryListRelationFilter
}

input EmployeeWhereUniqueInput {
  id: String
}

enum EnableStatus {
  DELETE
  HIDE
  SHOW
}

input FloatFieldUpdateOperationsInput {
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

type getEmployeesEarningArgs {
  data: [getEmployeesEarningRow!]
}

type getEmployeesEarningRow {
  id: String
  name: String
  remainingEarning: Float
}

type getQueuesArgs {
  activeQueues: [getQueuesRow!]
  recentQueue: Queue
}

type getQueuesRow {
  createdAt: DateTime
  id: Int
  name: String
  ordered: Boolean
  pictureUrl: String
  queueNo: String
  seat: Int
  status: String
  userId: String
}

enum HiringType {
  DAILY
  HOURLY
  MONTHLY
}

input IntFieldUpdateOperationsInput {
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type LogUser {
  createdAt: DateTime!
  id: String!
  role: UserRole!
  userId: String!
}

input LogUserCreateInput {
  createdAt: DateTime
  id: String
  role: UserRole!
  user: UserCreateOneWithoutLogUserInput!
}

input LogUserCreateManyWithoutUserInput {
  connect: [LogUserWhereUniqueInput!]
  create: [LogUserCreateWithoutUserInput!]
}

input LogUserCreateWithoutUserInput {
  createdAt: DateTime
  id: String
  role: UserRole!
}

input LogUserListRelationFilter {
  every: LogUserWhereInput
  none: LogUserWhereInput
  some: LogUserWhereInput
}

input LogUserScalarWhereInput {
  AND: [LogUserScalarWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [LogUserScalarWhereInput!]
  OR: [LogUserScalarWhereInput!]
  role: UserRole
  userId: StringFilter
}

input LogUserUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  role: UserRole
  user: UserUpdateOneRequiredWithoutLogUserInput
}

input LogUserUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  role: UserRole
}

input LogUserUpdateManyWithoutUserInput {
  connect: [LogUserWhereUniqueInput!]
  create: [LogUserCreateWithoutUserInput!]
  delete: [LogUserWhereUniqueInput!]
  deleteMany: [LogUserScalarWhereInput!]
  disconnect: [LogUserWhereUniqueInput!]
  set: [LogUserWhereUniqueInput!]
  update: [LogUserUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [LogUserUpdateManyWithWhereNestedInput!]
  upsert: [LogUserUpsertWithWhereUniqueWithoutUserInput!]
}

input LogUserUpdateManyWithWhereNestedInput {
  data: LogUserUpdateManyDataInput!
  where: LogUserScalarWhereInput!
}

input LogUserUpdateWithoutUserDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  role: UserRole
}

input LogUserUpdateWithWhereUniqueWithoutUserInput {
  data: LogUserUpdateWithoutUserDataInput!
  where: LogUserWhereUniqueInput!
}

input LogUserUpsertWithWhereUniqueWithoutUserInput {
  create: LogUserCreateWithoutUserInput!
  update: LogUserUpdateWithoutUserDataInput!
  where: LogUserWhereUniqueInput!
}

input LogUserWhereInput {
  AND: [LogUserWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [LogUserWhereInput!]
  OR: [LogUserWhereInput!]
  role: UserRole
  user: UserWhereInput
  userId: StringFilter
}

input LogUserWhereUniqueInput {
  id: String
  userId: String
}

type Mutation {
  bookQueue(name: String, pictureUrl: String, seat: Int!, userId: String): Boolean
  cancelQueue(id: Int!): Boolean
  createOneEmployee(data: EmployeeCreateInput!): Employee!
  createOneLogUser(data: LogUserCreateInput!): LogUser!
  createOneSteamer(data: SteamerCreateInput!): Steamer!
  createOneTask(data: TaskCreateInput!): Task!
  createOneUser(data: UserCreateInput!): User!
  createTask(countTime: Int!, finishTime: DateTime, name: String!, serverId: String, total: Int!, userId: String!): Task
  createUser(name: String!, password: String!, userName: String!): User
  deleteOneWorkingHistory(where: WorkingHistoryWhereUniqueInput!): WorkingHistory
  fetchQueue(id: Int!, tableId: Int): Boolean
  login(password: String!, userName: String!): LogUser
  orderFood(id: Int!): Boolean
  UpdateEditTask(name: String!, taskId: String!, total: Int!): Task
  updateOneEmployee(data: EmployeeUpdateInput!, where: EmployeeWhereUniqueInput!): Employee
  updateOneLogUser(data: LogUserUpdateInput!, where: LogUserWhereUniqueInput!): LogUser
  updateOneSteamer(data: SteamerUpdateInput!, where: SteamerWhereUniqueInput!): Steamer
  updateOneTask(data: TaskUpdateInput!, where: TaskWhereUniqueInput!): Task
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateSteamerComplete(taskId: String!): Boolean
  updateTaskCancel(taskId: String!): Task
  updateTaskComplete(taskId: String!): Task
  updateTaskOngoing(countTime: Int!, finishTime: DateTime, taskId: String!): Task
  updateTaskPriority(priority: Int!, taskId: String!): Task
  updateTaskTimeup(taskId: String!): Task
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NullableBoolFieldUpdateOperationsInput {
  set: Boolean
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Payroll {
  createdAt: DateTime!
  employee: Employee!
  employeeId: String!
  id: String!
  paid: Float!
  payrollDate: DateTime!
  updateAt: DateTime!
}

input PayrollCreateManyWithoutEmployeeInput {
  connect: [PayrollWhereUniqueInput!]
  create: [PayrollCreateWithoutEmployeeInput!]
}

input PayrollCreateWithoutEmployeeInput {
  createdAt: DateTime
  id: String
  paid: Float!
  payrollDate: DateTime!
  updateAt: DateTime
}

input PayrollListRelationFilter {
  every: PayrollWhereInput
  none: PayrollWhereInput
  some: PayrollWhereInput
}

input PayrollOrderByInput {
  createdAt: SortOrder
  employeeId: SortOrder
  id: SortOrder
  paid: SortOrder
  payrollDate: SortOrder
  updateAt: SortOrder
}

input PayrollScalarWhereInput {
  AND: [PayrollScalarWhereInput!]
  createdAt: DateTimeFilter
  employeeId: StringFilter
  id: StringFilter
  NOT: [PayrollScalarWhereInput!]
  OR: [PayrollScalarWhereInput!]
  paid: FloatFilter
  payrollDate: DateTimeFilter
  updateAt: DateTimeFilter
}

input PayrollUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  paid: FloatFieldUpdateOperationsInput
  payrollDate: DateTimeFieldUpdateOperationsInput
  updateAt: DateTimeFieldUpdateOperationsInput
}

input PayrollUpdateManyWithoutEmployeeInput {
  connect: [PayrollWhereUniqueInput!]
  create: [PayrollCreateWithoutEmployeeInput!]
  delete: [PayrollWhereUniqueInput!]
  deleteMany: [PayrollScalarWhereInput!]
  disconnect: [PayrollWhereUniqueInput!]
  set: [PayrollWhereUniqueInput!]
  update: [PayrollUpdateWithWhereUniqueWithoutEmployeeInput!]
  updateMany: [PayrollUpdateManyWithWhereNestedInput!]
  upsert: [PayrollUpsertWithWhereUniqueWithoutEmployeeInput!]
}

input PayrollUpdateManyWithWhereNestedInput {
  data: PayrollUpdateManyDataInput!
  where: PayrollScalarWhereInput!
}

input PayrollUpdateWithoutEmployeeDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  paid: FloatFieldUpdateOperationsInput
  payrollDate: DateTimeFieldUpdateOperationsInput
  updateAt: DateTimeFieldUpdateOperationsInput
}

input PayrollUpdateWithWhereUniqueWithoutEmployeeInput {
  data: PayrollUpdateWithoutEmployeeDataInput!
  where: PayrollWhereUniqueInput!
}

input PayrollUpsertWithWhereUniqueWithoutEmployeeInput {
  create: PayrollCreateWithoutEmployeeInput!
  update: PayrollUpdateWithoutEmployeeDataInput!
  where: PayrollWhereUniqueInput!
}

input PayrollWhereInput {
  AND: [PayrollWhereInput!]
  createdAt: DateTimeFilter
  employee: EmployeeWhereInput
  employeeId: StringFilter
  id: StringFilter
  NOT: [PayrollWhereInput!]
  OR: [PayrollWhereInput!]
  paid: FloatFilter
  payrollDate: DateTimeFilter
  updateAt: DateTimeFilter
}

input PayrollWhereUniqueInput {
  id: String
}

type Query {
  employees(after: EmployeeWhereUniqueInput, before: EmployeeWhereUniqueInput, first: Int, last: Int, orderBy: [EmployeeOrderByInput!], where: EmployeeWhereInput): [Employee!]!
  getEmployeesEarning: getEmployeesEarningArgs
  getMyQueue(userId: String!): Boolean
  getQueues: getQueuesArgs
  payrolls(after: PayrollWhereUniqueInput, before: PayrollWhereUniqueInput, first: Int, last: Int, orderBy: [PayrollOrderByInput!], where: PayrollWhereInput): [Payroll!]!
  queues(after: QueueWhereUniqueInput, before: QueueWhereUniqueInput, first: Int, last: Int, orderBy: [QueueOrderByInput!], where: QueueWhereInput): [Queue!]!
  steamers(after: SteamerWhereUniqueInput, before: SteamerWhereUniqueInput, first: Int, last: Int, orderBy: [SteamerOrderByInput!], where: SteamerWhereInput): [Steamer!]!
  tables(after: TableWhereUniqueInput, before: TableWhereUniqueInput, first: Int, last: Int, orderBy: [TableOrderByInput!], where: TableWhereInput): [Table!]!
  tasks(after: TaskWhereUniqueInput, before: TaskWhereUniqueInput, first: Int, last: Int, orderBy: [TaskOrderByInput!], where: TaskWhereInput): [Task!]!
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int, where: UserWhereInput): [User!]!
  workingHistories(after: WorkingHistoryWhereUniqueInput, before: WorkingHistoryWhereUniqueInput, first: Int, last: Int, orderBy: [WorkingHistoryOrderByInput!], where: WorkingHistoryWhereInput): [WorkingHistory!]!
}

type Queue {
  createdAt: DateTime!
  id: Int!
  name: String
  ordered: Boolean!
  pictureUrl: String
  queueNo: String!
  seat: Int!
  status: QueueStatus!
  table: Table
  tableId: Int
  updateAt: DateTime!
  userId: String
}

input QueueListRelationFilter {
  every: QueueWhereInput
  none: QueueWhereInput
  some: QueueWhereInput
}

input QueueOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  ordered: SortOrder
  pictureUrl: SortOrder
  queueNo: SortOrder
  seat: SortOrder
  status: SortOrder
  tableId: SortOrder
  updateAt: SortOrder
  userId: SortOrder
}

enum QueueStatus {
  ACTIVE
  CANCELLED
  SUCCESS
}

input QueueWhereInput {
  AND: [QueueWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringNullableFilter
  NOT: [QueueWhereInput!]
  OR: [QueueWhereInput!]
  ordered: BoolFilter
  pictureUrl: StringNullableFilter
  queueNo: StringFilter
  seat: IntFilter
  status: QueueStatus
  table: TableWhereInput
  tableId: IntNullableFilter
  updateAt: DateTimeFilter
  userId: StringNullableFilter
}

input QueueWhereUniqueInput {
  id: Int
}

enum SortOrder {
  asc
  desc
}

type Steamer {
  id: String!
  machineNo: Int!
  steamerNo: Int!
  Task: Task
  taskId: String
  updatedAt: DateTime!
  updatedBy: String!
}

input SteamerCreateInput {
  id: String
  machineNo: Int!
  steamerNo: Int!
  Task: TaskCreateOneWithoutSteamerInput
  updatedAt: DateTime
  updatedBy: String!
}

input SteamerCreateManyWithoutTaskInput {
  connect: [SteamerWhereUniqueInput!]
  create: [SteamerCreateWithoutTaskInput!]
}

input SteamerCreateWithoutTaskInput {
  id: String
  machineNo: Int!
  steamerNo: Int!
  updatedAt: DateTime
  updatedBy: String!
}

input SteamerListRelationFilter {
  every: SteamerWhereInput
  none: SteamerWhereInput
  some: SteamerWhereInput
}

input SteamerOrderByInput {
  id: SortOrder
  machineNo: SortOrder
  steamerNo: SortOrder
  taskId: SortOrder
  updatedAt: SortOrder
  updatedBy: SortOrder
}

input SteamerScalarWhereInput {
  AND: [SteamerScalarWhereInput!]
  id: StringFilter
  machineNo: IntFilter
  NOT: [SteamerScalarWhereInput!]
  OR: [SteamerScalarWhereInput!]
  steamerNo: IntFilter
  taskId: StringNullableFilter
  updatedAt: DateTimeFilter
  updatedBy: StringFilter
}

input SteamerUpdateInput {
  id: StringFieldUpdateOperationsInput
  machineNo: IntFieldUpdateOperationsInput
  steamerNo: IntFieldUpdateOperationsInput
  Task: TaskUpdateOneWithoutSteamerInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
}

input SteamerUpdateManyDataInput {
  id: StringFieldUpdateOperationsInput
  machineNo: IntFieldUpdateOperationsInput
  steamerNo: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
}

input SteamerUpdateManyWithoutTaskInput {
  connect: [SteamerWhereUniqueInput!]
  create: [SteamerCreateWithoutTaskInput!]
  delete: [SteamerWhereUniqueInput!]
  deleteMany: [SteamerScalarWhereInput!]
  disconnect: [SteamerWhereUniqueInput!]
  set: [SteamerWhereUniqueInput!]
  update: [SteamerUpdateWithWhereUniqueWithoutTaskInput!]
  updateMany: [SteamerUpdateManyWithWhereNestedInput!]
  upsert: [SteamerUpsertWithWhereUniqueWithoutTaskInput!]
}

input SteamerUpdateManyWithWhereNestedInput {
  data: SteamerUpdateManyDataInput!
  where: SteamerScalarWhereInput!
}

input SteamerUpdateWithoutTaskDataInput {
  id: StringFieldUpdateOperationsInput
  machineNo: IntFieldUpdateOperationsInput
  steamerNo: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
}

input SteamerUpdateWithWhereUniqueWithoutTaskInput {
  data: SteamerUpdateWithoutTaskDataInput!
  where: SteamerWhereUniqueInput!
}

input SteamerUpsertWithWhereUniqueWithoutTaskInput {
  create: SteamerCreateWithoutTaskInput!
  update: SteamerUpdateWithoutTaskDataInput!
  where: SteamerWhereUniqueInput!
}

input SteamerWhereInput {
  AND: [SteamerWhereInput!]
  id: StringFilter
  machineNo: IntFilter
  NOT: [SteamerWhereInput!]
  OR: [SteamerWhereInput!]
  steamerNo: IntFilter
  Task: TaskWhereInput
  taskId: StringNullableFilter
  updatedAt: DateTimeFilter
  updatedBy: StringFilter
}

input SteamerWhereUniqueInput {
  id: String
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Table {
  id: Int!
  ochaTableName: String!
  tableName: String!
}

input TableOrderByInput {
  id: SortOrder
  ochaTableName: SortOrder
  tableName: SortOrder
}

input TableWhereInput {
  AND: [TableWhereInput!]
  id: IntFilter
  NOT: [TableWhereInput!]
  ochaTableName: StringFilter
  OR: [TableWhereInput!]
  Queue: QueueListRelationFilter
  tableName: StringFilter
}

input TableWhereUniqueInput {
  id: Int
}

type Task {
  countTime: Int!
  finishTime: DateTime!
  id: String!
  name: String!
  priority: Int!
  serverId: String
  status: TaskStatus!
  total: Int!
  updatedAt: DateTime!
}

input TaskCreateInput {
  countTime: Int!
  createdAt: DateTime
  finishTime: DateTime!
  id: String
  name: String!
  priority: Int!
  serverId: String
  status: TaskStatus!
  Steamer: SteamerCreateManyWithoutTaskInput
  total: Int!
  updatedAt: DateTime
  updatedBy: String!
  user: UserCreateOneWithoutTaskInput!
}

input TaskCreateManyWithoutUserInput {
  connect: [TaskWhereUniqueInput!]
  create: [TaskCreateWithoutUserInput!]
}

input TaskCreateOneWithoutSteamerInput {
  connect: TaskWhereUniqueInput
  create: TaskCreateWithoutSteamerInput
}

input TaskCreateWithoutSteamerInput {
  countTime: Int!
  createdAt: DateTime
  finishTime: DateTime!
  id: String
  name: String!
  priority: Int!
  serverId: String
  status: TaskStatus!
  total: Int!
  updatedAt: DateTime
  updatedBy: String!
  user: UserCreateOneWithoutTaskInput!
}

input TaskCreateWithoutUserInput {
  countTime: Int!
  createdAt: DateTime
  finishTime: DateTime!
  id: String
  name: String!
  priority: Int!
  serverId: String
  status: TaskStatus!
  Steamer: SteamerCreateManyWithoutTaskInput
  total: Int!
  updatedAt: DateTime
  updatedBy: String!
}

input TaskListRelationFilter {
  every: TaskWhereInput
  none: TaskWhereInput
  some: TaskWhereInput
}

input TaskOrderByInput {
  countTime: SortOrder
  createdAt: SortOrder
  createdBy: SortOrder
  finishTime: SortOrder
  id: SortOrder
  name: SortOrder
  priority: SortOrder
  serverId: SortOrder
  status: SortOrder
  total: SortOrder
  updatedAt: SortOrder
  updatedBy: SortOrder
}

input TaskScalarWhereInput {
  AND: [TaskScalarWhereInput!]
  countTime: IntFilter
  createdAt: DateTimeFilter
  createdBy: StringFilter
  finishTime: DateTimeFilter
  id: StringFilter
  name: StringFilter
  NOT: [TaskScalarWhereInput!]
  OR: [TaskScalarWhereInput!]
  priority: IntFilter
  serverId: StringNullableFilter
  status: TaskStatus
  total: IntFilter
  updatedAt: DateTimeFilter
  updatedBy: StringFilter
}

enum TaskStatus {
  CANCELED
  COMPLETED
  ONGOING
  PENDING
  TIMEUP
}

input TaskUpdateInput {
  countTime: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  finishTime: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  priority: IntFieldUpdateOperationsInput
  serverId: NullableStringFieldUpdateOperationsInput
  status: TaskStatus
  Steamer: SteamerUpdateManyWithoutTaskInput
  total: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutTaskInput
}

input TaskUpdateManyDataInput {
  countTime: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  finishTime: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  priority: IntFieldUpdateOperationsInput
  serverId: NullableStringFieldUpdateOperationsInput
  status: TaskStatus
  total: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
}

input TaskUpdateManyWithoutUserInput {
  connect: [TaskWhereUniqueInput!]
  create: [TaskCreateWithoutUserInput!]
  delete: [TaskWhereUniqueInput!]
  deleteMany: [TaskScalarWhereInput!]
  disconnect: [TaskWhereUniqueInput!]
  set: [TaskWhereUniqueInput!]
  update: [TaskUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [TaskUpdateManyWithWhereNestedInput!]
  upsert: [TaskUpsertWithWhereUniqueWithoutUserInput!]
}

input TaskUpdateManyWithWhereNestedInput {
  data: TaskUpdateManyDataInput!
  where: TaskScalarWhereInput!
}

input TaskUpdateOneWithoutSteamerInput {
  connect: TaskWhereUniqueInput
  create: TaskCreateWithoutSteamerInput
  delete: Boolean
  disconnect: Boolean
  update: TaskUpdateWithoutSteamerDataInput
  upsert: TaskUpsertWithoutSteamerInput
}

input TaskUpdateWithoutSteamerDataInput {
  countTime: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  finishTime: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  priority: IntFieldUpdateOperationsInput
  serverId: NullableStringFieldUpdateOperationsInput
  status: TaskStatus
  total: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutTaskInput
}

input TaskUpdateWithoutUserDataInput {
  countTime: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  finishTime: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  priority: IntFieldUpdateOperationsInput
  serverId: NullableStringFieldUpdateOperationsInput
  status: TaskStatus
  Steamer: SteamerUpdateManyWithoutTaskInput
  total: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
}

input TaskUpdateWithWhereUniqueWithoutUserInput {
  data: TaskUpdateWithoutUserDataInput!
  where: TaskWhereUniqueInput!
}

input TaskUpsertWithoutSteamerInput {
  create: TaskCreateWithoutSteamerInput!
  update: TaskUpdateWithoutSteamerDataInput!
}

input TaskUpsertWithWhereUniqueWithoutUserInput {
  create: TaskCreateWithoutUserInput!
  update: TaskUpdateWithoutUserDataInput!
  where: TaskWhereUniqueInput!
}

input TaskWhereInput {
  AND: [TaskWhereInput!]
  countTime: IntFilter
  createdAt: DateTimeFilter
  createdBy: StringFilter
  finishTime: DateTimeFilter
  id: StringFilter
  name: StringFilter
  NOT: [TaskWhereInput!]
  OR: [TaskWhereInput!]
  priority: IntFilter
  serverId: StringNullableFilter
  status: TaskStatus
  Steamer: SteamerListRelationFilter
  total: IntFilter
  updatedAt: DateTimeFilter
  updatedBy: StringFilter
  user: UserWhereInput
}

input TaskWhereUniqueInput {
  createdBy: String
  id: String
}

type User {
  enableStatus: EnableStatus!
  id: String!
  isSuperAdmin: Boolean
  name: String
  userName: String!
}

input UserCreateInput {
  createdAt: DateTime
  enableStatus: EnableStatus!
  id: String
  isSuperAdmin: Boolean
  LogUser: LogUserCreateManyWithoutUserInput
  name: String
  password: String!
  Task: TaskCreateManyWithoutUserInput
  updatedAt: DateTime
  userName: String!
}

input UserCreateOneWithoutLogUserInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutLogUserInput
}

input UserCreateOneWithoutTaskInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTaskInput
}

input UserCreateWithoutLogUserInput {
  createdAt: DateTime
  enableStatus: EnableStatus!
  id: String
  isSuperAdmin: Boolean
  name: String
  password: String!
  Task: TaskCreateManyWithoutUserInput
  updatedAt: DateTime
  userName: String!
}

input UserCreateWithoutTaskInput {
  createdAt: DateTime
  enableStatus: EnableStatus!
  id: String
  isSuperAdmin: Boolean
  LogUser: LogUserCreateManyWithoutUserInput
  name: String
  password: String!
  updatedAt: DateTime
  userName: String!
}

enum UserRole {
  CASHIER
  CHEF
  NONE
}

input UserUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  enableStatus: EnableStatus
  id: StringFieldUpdateOperationsInput
  isSuperAdmin: NullableBoolFieldUpdateOperationsInput
  LogUser: LogUserUpdateManyWithoutUserInput
  name: NullableStringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  Task: TaskUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userName: StringFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutLogUserInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutLogUserInput
  update: UserUpdateWithoutLogUserDataInput
  upsert: UserUpsertWithoutLogUserInput
}

input UserUpdateOneRequiredWithoutTaskInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTaskInput
  update: UserUpdateWithoutTaskDataInput
  upsert: UserUpsertWithoutTaskInput
}

input UserUpdateWithoutLogUserDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  enableStatus: EnableStatus
  id: StringFieldUpdateOperationsInput
  isSuperAdmin: NullableBoolFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  Task: TaskUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userName: StringFieldUpdateOperationsInput
}

input UserUpdateWithoutTaskDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  enableStatus: EnableStatus
  id: StringFieldUpdateOperationsInput
  isSuperAdmin: NullableBoolFieldUpdateOperationsInput
  LogUser: LogUserUpdateManyWithoutUserInput
  name: NullableStringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userName: StringFieldUpdateOperationsInput
}

input UserUpsertWithoutLogUserInput {
  create: UserCreateWithoutLogUserInput!
  update: UserUpdateWithoutLogUserDataInput!
}

input UserUpsertWithoutTaskInput {
  create: UserCreateWithoutTaskInput!
  update: UserUpdateWithoutTaskDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  createdAt: DateTimeFilter
  enableStatus: EnableStatus
  id: StringFilter
  isSuperAdmin: BoolNullableFilter
  LogUser: LogUserListRelationFilter
  name: StringNullableFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
  Task: TaskListRelationFilter
  updatedAt: DateTimeFilter
  userName: StringFilter
}

input UserWhereUniqueInput {
  id: String
  userName: String
}

type WorkingHistory {
  createdAt: DateTime!
  earning: Float!
  earningRate: Float!
  employee: Employee!
  employeeId: String!
  hiringType: HiringType!
  historyDate: DateTime!
  hours: Float!
  id: String!
  updateAt: DateTime!
}

input WorkingHistoryCreateManyWithoutEmployeeInput {
  connect: [WorkingHistoryWhereUniqueInput!]
  create: [WorkingHistoryCreateWithoutEmployeeInput!]
}

input WorkingHistoryCreateWithoutEmployeeInput {
  createdAt: DateTime
  earning: Float!
  earningRate: Float!
  hiringType: HiringType!
  historyDate: DateTime!
  hours: Float!
  id: String
  updateAt: DateTime
}

input WorkingHistoryListRelationFilter {
  every: WorkingHistoryWhereInput
  none: WorkingHistoryWhereInput
  some: WorkingHistoryWhereInput
}

input WorkingHistoryOrderByInput {
  createdAt: SortOrder
  earning: SortOrder
  earningRate: SortOrder
  employeeId: SortOrder
  hiringType: SortOrder
  historyDate: SortOrder
  hours: SortOrder
  id: SortOrder
  updateAt: SortOrder
}

input WorkingHistoryScalarWhereInput {
  AND: [WorkingHistoryScalarWhereInput!]
  createdAt: DateTimeFilter
  earning: FloatFilter
  earningRate: FloatFilter
  employeeId: StringFilter
  hiringType: HiringType
  historyDate: DateTimeFilter
  hours: FloatFilter
  id: StringFilter
  NOT: [WorkingHistoryScalarWhereInput!]
  OR: [WorkingHistoryScalarWhereInput!]
  updateAt: DateTimeFilter
}

input WorkingHistoryUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  earning: FloatFieldUpdateOperationsInput
  earningRate: FloatFieldUpdateOperationsInput
  hiringType: HiringType
  historyDate: DateTimeFieldUpdateOperationsInput
  hours: FloatFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  updateAt: DateTimeFieldUpdateOperationsInput
}

input WorkingHistoryUpdateManyWithoutEmployeeInput {
  connect: [WorkingHistoryWhereUniqueInput!]
  create: [WorkingHistoryCreateWithoutEmployeeInput!]
  delete: [WorkingHistoryWhereUniqueInput!]
  deleteMany: [WorkingHistoryScalarWhereInput!]
  disconnect: [WorkingHistoryWhereUniqueInput!]
  set: [WorkingHistoryWhereUniqueInput!]
  update: [WorkingHistoryUpdateWithWhereUniqueWithoutEmployeeInput!]
  updateMany: [WorkingHistoryUpdateManyWithWhereNestedInput!]
  upsert: [WorkingHistoryUpsertWithWhereUniqueWithoutEmployeeInput!]
}

input WorkingHistoryUpdateManyWithWhereNestedInput {
  data: WorkingHistoryUpdateManyDataInput!
  where: WorkingHistoryScalarWhereInput!
}

input WorkingHistoryUpdateWithoutEmployeeDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  earning: FloatFieldUpdateOperationsInput
  earningRate: FloatFieldUpdateOperationsInput
  hiringType: HiringType
  historyDate: DateTimeFieldUpdateOperationsInput
  hours: FloatFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  updateAt: DateTimeFieldUpdateOperationsInput
}

input WorkingHistoryUpdateWithWhereUniqueWithoutEmployeeInput {
  data: WorkingHistoryUpdateWithoutEmployeeDataInput!
  where: WorkingHistoryWhereUniqueInput!
}

input WorkingHistoryUpsertWithWhereUniqueWithoutEmployeeInput {
  create: WorkingHistoryCreateWithoutEmployeeInput!
  update: WorkingHistoryUpdateWithoutEmployeeDataInput!
  where: WorkingHistoryWhereUniqueInput!
}

input WorkingHistoryWhereInput {
  AND: [WorkingHistoryWhereInput!]
  createdAt: DateTimeFilter
  earning: FloatFilter
  earningRate: FloatFilter
  employee: EmployeeWhereInput
  employeeId: StringFilter
  hiringType: HiringType
  historyDate: DateTimeFilter
  hours: FloatFilter
  id: StringFilter
  NOT: [WorkingHistoryWhereInput!]
  OR: [WorkingHistoryWhereInput!]
  updateAt: DateTimeFilter
}

input WorkingHistoryWhereUniqueInput {
  id: String
}
