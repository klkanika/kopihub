### This file was generated by Nexus Schema
### Do not make changes to this file directly


"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

enum EnableStatus {
  DELETE
  HIDE
  SHOW
}

input IntFieldUpdateOperationsInput {
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type LogUser {
  createdAt: DateTime!
  id: String!
  role: UserRole!
  userId: String!
}

input LogUserCreateInput {
  createdAt: DateTime
  id: String
  role: UserRole!
  user: UserCreateOneWithoutLogUserInput!
}

input LogUserCreateManyWithoutUserInput {
  connect: [LogUserWhereUniqueInput!]
  create: [LogUserCreateWithoutUserInput!]
}

input LogUserCreateWithoutUserInput {
  createdAt: DateTime
  id: String
  role: UserRole!
}

input LogUserListRelationFilter {
  every: LogUserWhereInput
  none: LogUserWhereInput
  some: LogUserWhereInput
}

input LogUserScalarWhereInput {
  AND: [LogUserScalarWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [LogUserScalarWhereInput!]
  OR: [LogUserScalarWhereInput!]
  role: UserRole
  userId: StringFilter
}

input LogUserUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  role: UserRole
  user: UserUpdateOneRequiredWithoutLogUserInput
}

input LogUserUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  role: UserRole
}

input LogUserUpdateManyWithoutUserInput {
  connect: [LogUserWhereUniqueInput!]
  create: [LogUserCreateWithoutUserInput!]
  delete: [LogUserWhereUniqueInput!]
  deleteMany: [LogUserScalarWhereInput!]
  disconnect: [LogUserWhereUniqueInput!]
  set: [LogUserWhereUniqueInput!]
  update: [LogUserUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [LogUserUpdateManyWithWhereNestedInput!]
  upsert: [LogUserUpsertWithWhereUniqueWithoutUserInput!]
}

input LogUserUpdateManyWithWhereNestedInput {
  data: LogUserUpdateManyDataInput!
  where: LogUserScalarWhereInput!
}

input LogUserUpdateWithoutUserDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  role: UserRole
}

input LogUserUpdateWithWhereUniqueWithoutUserInput {
  data: LogUserUpdateWithoutUserDataInput!
  where: LogUserWhereUniqueInput!
}

input LogUserUpsertWithWhereUniqueWithoutUserInput {
  create: LogUserCreateWithoutUserInput!
  update: LogUserUpdateWithoutUserDataInput!
  where: LogUserWhereUniqueInput!
}

input LogUserWhereInput {
  AND: [LogUserWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [LogUserWhereInput!]
  OR: [LogUserWhereInput!]
  role: UserRole
  user: UserWhereInput
  userId: StringFilter
}

input LogUserWhereUniqueInput {
  id: String
  userId: String
}

type Mutation {
  createOneLogUser(data: LogUserCreateInput!): LogUser!
  createOneTask(data: TaskCreateInput!): Task!
  createOneUser(data: UserCreateInput!): User!
  createTask(countTime: Int!, finishTime: DateTime, name: String!, total: Int!, userId: String!): Task
  createUser(name: String!, password: String!, userName: String!): User
  login(password: String!, userName: String!): LogUser
  updateOneLogUser(data: LogUserUpdateInput!, where: LogUserWhereUniqueInput!): LogUser
  updateOneTask(data: TaskUpdateInput!, where: TaskWhereUniqueInput!): Task
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateTaskCancel(taskId: String!): Task
  updateTaskComplete(taskId: String!): Task
  updateTaskOngoing(countTime: Int!, finishTime: DateTime, taskId: String!): Task
  updateTaskPriority(priority: Int!, taskId: String!): Task
  updateTaskTimeup(taskId: String!): Task
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  tasks(after: TaskWhereUniqueInput, before: TaskWhereUniqueInput, first: Int, last: Int, orderBy: [TaskOrderByInput!], where: TaskWhereInput): [Task!]!
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int, where: UserWhereInput): [User!]!
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Task {
  countTime: Int!
  finishTime: DateTime!
  id: String!
  name: String!
  priority: Int!
  status: TaskStatus!
  total: Int!
  updatedAt: DateTime!
}

input TaskCreateInput {
  countTime: Int!
  createdAt: DateTime
  finishTime: DateTime!
  id: String
  name: String!
  priority: Int!
  status: TaskStatus!
  total: Int!
  updatedAt: DateTime
  updatedBy: String!
  user: UserCreateOneWithoutTaskInput!
}

input TaskCreateManyWithoutUserInput {
  connect: [TaskWhereUniqueInput!]
  create: [TaskCreateWithoutUserInput!]
}

input TaskCreateWithoutUserInput {
  countTime: Int!
  createdAt: DateTime
  finishTime: DateTime!
  id: String
  name: String!
  priority: Int!
  status: TaskStatus!
  total: Int!
  updatedAt: DateTime
  updatedBy: String!
}

input TaskListRelationFilter {
  every: TaskWhereInput
  none: TaskWhereInput
  some: TaskWhereInput
}

input TaskOrderByInput {
  countTime: SortOrder
  createdAt: SortOrder
  createdBy: SortOrder
  finishTime: SortOrder
  id: SortOrder
  name: SortOrder
  priority: SortOrder
  status: SortOrder
  total: SortOrder
  updatedAt: SortOrder
  updatedBy: SortOrder
}

input TaskScalarWhereInput {
  AND: [TaskScalarWhereInput!]
  countTime: IntFilter
  createdAt: DateTimeFilter
  createdBy: StringFilter
  finishTime: DateTimeFilter
  id: StringFilter
  name: StringFilter
  NOT: [TaskScalarWhereInput!]
  OR: [TaskScalarWhereInput!]
  priority: IntFilter
  status: TaskStatus
  total: IntFilter
  updatedAt: DateTimeFilter
  updatedBy: StringFilter
}

enum TaskStatus {
  CANCELED
  COMPLETED
  ONGOING
  PENDING
  TIMEUP
}

input TaskUpdateInput {
  countTime: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  finishTime: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  priority: IntFieldUpdateOperationsInput
  status: TaskStatus
  total: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutTaskInput
}

input TaskUpdateManyDataInput {
  countTime: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  finishTime: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  priority: IntFieldUpdateOperationsInput
  status: TaskStatus
  total: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
}

input TaskUpdateManyWithoutUserInput {
  connect: [TaskWhereUniqueInput!]
  create: [TaskCreateWithoutUserInput!]
  delete: [TaskWhereUniqueInput!]
  deleteMany: [TaskScalarWhereInput!]
  disconnect: [TaskWhereUniqueInput!]
  set: [TaskWhereUniqueInput!]
  update: [TaskUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [TaskUpdateManyWithWhereNestedInput!]
  upsert: [TaskUpsertWithWhereUniqueWithoutUserInput!]
}

input TaskUpdateManyWithWhereNestedInput {
  data: TaskUpdateManyDataInput!
  where: TaskScalarWhereInput!
}

input TaskUpdateWithoutUserDataInput {
  countTime: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  finishTime: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  priority: IntFieldUpdateOperationsInput
  status: TaskStatus
  total: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
}

input TaskUpdateWithWhereUniqueWithoutUserInput {
  data: TaskUpdateWithoutUserDataInput!
  where: TaskWhereUniqueInput!
}

input TaskUpsertWithWhereUniqueWithoutUserInput {
  create: TaskCreateWithoutUserInput!
  update: TaskUpdateWithoutUserDataInput!
  where: TaskWhereUniqueInput!
}

input TaskWhereInput {
  AND: [TaskWhereInput!]
  countTime: IntFilter
  createdAt: DateTimeFilter
  createdBy: StringFilter
  finishTime: DateTimeFilter
  id: StringFilter
  name: StringFilter
  NOT: [TaskWhereInput!]
  OR: [TaskWhereInput!]
  priority: IntFilter
  status: TaskStatus
  total: IntFilter
  updatedAt: DateTimeFilter
  updatedBy: StringFilter
  user: UserWhereInput
}

input TaskWhereUniqueInput {
  createdBy: String
  id: String
}

type User {
  enableStatus: EnableStatus!
  id: String!
  name: String
  userName: String!
}

input UserCreateInput {
  createdAt: DateTime
  enableStatus: EnableStatus!
  id: String
  LogUser: LogUserCreateManyWithoutUserInput
  name: String
  password: String!
  Task: TaskCreateManyWithoutUserInput
  updatedAt: DateTime
  userName: String!
}

input UserCreateOneWithoutLogUserInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutLogUserInput
}

input UserCreateOneWithoutTaskInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTaskInput
}

input UserCreateWithoutLogUserInput {
  createdAt: DateTime
  enableStatus: EnableStatus!
  id: String
  name: String
  password: String!
  Task: TaskCreateManyWithoutUserInput
  updatedAt: DateTime
  userName: String!
}

input UserCreateWithoutTaskInput {
  createdAt: DateTime
  enableStatus: EnableStatus!
  id: String
  LogUser: LogUserCreateManyWithoutUserInput
  name: String
  password: String!
  updatedAt: DateTime
  userName: String!
}

enum UserRole {
  CASHIER
  CHEF
  NONE
}

input UserUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  enableStatus: EnableStatus
  id: StringFieldUpdateOperationsInput
  LogUser: LogUserUpdateManyWithoutUserInput
  name: NullableStringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  Task: TaskUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userName: StringFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutLogUserInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutLogUserInput
  update: UserUpdateWithoutLogUserDataInput
  upsert: UserUpsertWithoutLogUserInput
}

input UserUpdateOneRequiredWithoutTaskInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTaskInput
  update: UserUpdateWithoutTaskDataInput
  upsert: UserUpsertWithoutTaskInput
}

input UserUpdateWithoutLogUserDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  enableStatus: EnableStatus
  id: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  Task: TaskUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userName: StringFieldUpdateOperationsInput
}

input UserUpdateWithoutTaskDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  enableStatus: EnableStatus
  id: StringFieldUpdateOperationsInput
  LogUser: LogUserUpdateManyWithoutUserInput
  name: NullableStringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userName: StringFieldUpdateOperationsInput
}

input UserUpsertWithoutLogUserInput {
  create: UserCreateWithoutLogUserInput!
  update: UserUpdateWithoutLogUserDataInput!
}

input UserUpsertWithoutTaskInput {
  create: UserCreateWithoutTaskInput!
  update: UserUpdateWithoutTaskDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  createdAt: DateTimeFilter
  enableStatus: EnableStatus
  id: StringFilter
  LogUser: LogUserListRelationFilter
  name: StringNullableFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
  Task: TaskListRelationFilter
  updatedAt: DateTimeFilter
  userName: StringFilter
}

input UserWhereUniqueInput {
  id: String
  userName: String
}
