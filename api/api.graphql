### This file was generated by Nexus Schema
### Do not make changes to this file directly


input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

enum EnableStatus {
  DELETE
  HIDE
  SHOW
}

type getQueuesArgs {
  activeQueues: [getQueuesRow!]
  recentQueue: Queue
}

type getQueuesRow {
  createdAt: DateTime
  id: Int
  name: String
  ordered: Boolean
  pictureUrl: String
  queueNo: String
  seat: Int
  status: String
  userId: String
}

input IntFieldUpdateOperationsInput {
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type LogUser {
  createdAt: DateTime!
  id: String!
  role: UserRole!
  userId: String!
}

input LogUserCreateInput {
  createdAt: DateTime
  id: String
  role: UserRole!
  user: UserCreateOneWithoutLogUserInput!
}

input LogUserCreateManyWithoutUserInput {
  connect: [LogUserWhereUniqueInput!]
  create: [LogUserCreateWithoutUserInput!]
}

input LogUserCreateWithoutUserInput {
  createdAt: DateTime
  id: String
  role: UserRole!
}

input LogUserListRelationFilter {
  every: LogUserWhereInput
  none: LogUserWhereInput
  some: LogUserWhereInput
}

input LogUserScalarWhereInput {
  AND: [LogUserScalarWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [LogUserScalarWhereInput!]
  OR: [LogUserScalarWhereInput!]
  role: UserRole
  userId: StringFilter
}

input LogUserUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  role: UserRole
  user: UserUpdateOneRequiredWithoutLogUserInput
}

input LogUserUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  role: UserRole
}

input LogUserUpdateManyWithoutUserInput {
  connect: [LogUserWhereUniqueInput!]
  create: [LogUserCreateWithoutUserInput!]
  delete: [LogUserWhereUniqueInput!]
  deleteMany: [LogUserScalarWhereInput!]
  disconnect: [LogUserWhereUniqueInput!]
  set: [LogUserWhereUniqueInput!]
  update: [LogUserUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [LogUserUpdateManyWithWhereNestedInput!]
  upsert: [LogUserUpsertWithWhereUniqueWithoutUserInput!]
}

input LogUserUpdateManyWithWhereNestedInput {
  data: LogUserUpdateManyDataInput!
  where: LogUserScalarWhereInput!
}

input LogUserUpdateWithoutUserDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  role: UserRole
}

input LogUserUpdateWithWhereUniqueWithoutUserInput {
  data: LogUserUpdateWithoutUserDataInput!
  where: LogUserWhereUniqueInput!
}

input LogUserUpsertWithWhereUniqueWithoutUserInput {
  create: LogUserCreateWithoutUserInput!
  update: LogUserUpdateWithoutUserDataInput!
  where: LogUserWhereUniqueInput!
}

input LogUserWhereInput {
  AND: [LogUserWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [LogUserWhereInput!]
  OR: [LogUserWhereInput!]
  role: UserRole
  user: UserWhereInput
  userId: StringFilter
}

input LogUserWhereUniqueInput {
  id: String
  userId: String
}

type Mutation {
  bookQueue(name: String, pictureUrl: String, seat: Int!, userId: String): Boolean
  cancelQueue(id: Int!): Boolean
  createOneLogUser(data: LogUserCreateInput!): LogUser!
  createOneSteamer(data: SteamerCreateInput!): Steamer!
  createOneTask(data: TaskCreateInput!): Task!
  createOneUser(data: UserCreateInput!): User!
  createTask(countTime: Int!, finishTime: DateTime, name: String!, serverId: String, total: Int!, userId: String!): Task
  createUser(name: String!, password: String!, userName: String!): User
  fetchQueue(id: Int!): Boolean
  login(password: String!, userName: String!): LogUser
  orderFood(id: Int!): Boolean
  UpdateEditTask(name: String!, taskId: String!, total: Int!): Task
  updateOneLogUser(data: LogUserUpdateInput!, where: LogUserWhereUniqueInput!): LogUser
  updateOneSteamer(data: SteamerUpdateInput!, where: SteamerWhereUniqueInput!): Steamer
  updateOneTask(data: TaskUpdateInput!, where: TaskWhereUniqueInput!): Task
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateSteamerComplete(taskId: String!): Boolean
  updateTaskCancel(taskId: String!): Task
  updateTaskComplete(taskId: String!): Task
  updateTaskOngoing(countTime: Int!, finishTime: DateTime, taskId: String!): Task
  updateTaskPriority(priority: Int!, taskId: String!): Task
  updateTaskTimeup(taskId: String!): Task
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  getMyQueue(userId: String!): Boolean
  getQueues: getQueuesArgs
  queues(after: QueueWhereUniqueInput, before: QueueWhereUniqueInput, first: Int, last: Int, orderBy: [QueueOrderByInput!], where: QueueWhereInput): [Queue!]!
  steamers(after: SteamerWhereUniqueInput, before: SteamerWhereUniqueInput, first: Int, last: Int, orderBy: [SteamerOrderByInput!], where: SteamerWhereInput): [Steamer!]!
  tasks(after: TaskWhereUniqueInput, before: TaskWhereUniqueInput, first: Int, last: Int, orderBy: [TaskOrderByInput!], where: TaskWhereInput): [Task!]!
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int, where: UserWhereInput): [User!]!
}

type Queue {
  createdAt: DateTime!
  id: Int!
  name: String
  ordered: Boolean!
  pictureUrl: String
  queueNo: String!
  seat: Int!
  status: QueueStatus!
  userId: String
}

input QueueOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  ordered: SortOrder
  pictureUrl: SortOrder
  queueNo: SortOrder
  seat: SortOrder
  status: SortOrder
  userId: SortOrder
}

enum QueueStatus {
  ACTIVE
  CANCELLED
  SUCCESS
}

input QueueWhereInput {
  AND: [QueueWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringNullableFilter
  NOT: [QueueWhereInput!]
  OR: [QueueWhereInput!]
  ordered: BoolFilter
  pictureUrl: StringNullableFilter
  queueNo: StringFilter
  seat: IntFilter
  status: QueueStatus
  userId: StringNullableFilter
}

input QueueWhereUniqueInput {
  id: Int
}

enum SortOrder {
  asc
  desc
}

type Steamer {
  id: String!
  machineNo: Int!
  steamerNo: Int!
  Task: Task
  taskId: String
  updatedAt: DateTime!
  updatedBy: String!
}

input SteamerCreateInput {
  id: String
  machineNo: Int!
  steamerNo: Int!
  Task: TaskCreateOneWithoutSteamerInput
  updatedAt: DateTime
  updatedBy: String!
}

input SteamerCreateManyWithoutTaskInput {
  connect: [SteamerWhereUniqueInput!]
  create: [SteamerCreateWithoutTaskInput!]
}

input SteamerCreateWithoutTaskInput {
  id: String
  machineNo: Int!
  steamerNo: Int!
  updatedAt: DateTime
  updatedBy: String!
}

input SteamerListRelationFilter {
  every: SteamerWhereInput
  none: SteamerWhereInput
  some: SteamerWhereInput
}

input SteamerOrderByInput {
  id: SortOrder
  machineNo: SortOrder
  steamerNo: SortOrder
  taskId: SortOrder
  updatedAt: SortOrder
  updatedBy: SortOrder
}

input SteamerScalarWhereInput {
  AND: [SteamerScalarWhereInput!]
  id: StringFilter
  machineNo: IntFilter
  NOT: [SteamerScalarWhereInput!]
  OR: [SteamerScalarWhereInput!]
  steamerNo: IntFilter
  taskId: StringNullableFilter
  updatedAt: DateTimeFilter
  updatedBy: StringFilter
}

input SteamerUpdateInput {
  id: StringFieldUpdateOperationsInput
  machineNo: IntFieldUpdateOperationsInput
  steamerNo: IntFieldUpdateOperationsInput
  Task: TaskUpdateOneWithoutSteamerInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
}

input SteamerUpdateManyDataInput {
  id: StringFieldUpdateOperationsInput
  machineNo: IntFieldUpdateOperationsInput
  steamerNo: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
}

input SteamerUpdateManyWithoutTaskInput {
  connect: [SteamerWhereUniqueInput!]
  create: [SteamerCreateWithoutTaskInput!]
  delete: [SteamerWhereUniqueInput!]
  deleteMany: [SteamerScalarWhereInput!]
  disconnect: [SteamerWhereUniqueInput!]
  set: [SteamerWhereUniqueInput!]
  update: [SteamerUpdateWithWhereUniqueWithoutTaskInput!]
  updateMany: [SteamerUpdateManyWithWhereNestedInput!]
  upsert: [SteamerUpsertWithWhereUniqueWithoutTaskInput!]
}

input SteamerUpdateManyWithWhereNestedInput {
  data: SteamerUpdateManyDataInput!
  where: SteamerScalarWhereInput!
}

input SteamerUpdateWithoutTaskDataInput {
  id: StringFieldUpdateOperationsInput
  machineNo: IntFieldUpdateOperationsInput
  steamerNo: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
}

input SteamerUpdateWithWhereUniqueWithoutTaskInput {
  data: SteamerUpdateWithoutTaskDataInput!
  where: SteamerWhereUniqueInput!
}

input SteamerUpsertWithWhereUniqueWithoutTaskInput {
  create: SteamerCreateWithoutTaskInput!
  update: SteamerUpdateWithoutTaskDataInput!
  where: SteamerWhereUniqueInput!
}

input SteamerWhereInput {
  AND: [SteamerWhereInput!]
  id: StringFilter
  machineNo: IntFilter
  NOT: [SteamerWhereInput!]
  OR: [SteamerWhereInput!]
  steamerNo: IntFilter
  Task: TaskWhereInput
  taskId: StringNullableFilter
  updatedAt: DateTimeFilter
  updatedBy: StringFilter
}

input SteamerWhereUniqueInput {
  id: String
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Task {
  countTime: Int!
  finishTime: DateTime!
  id: String!
  name: String!
  priority: Int!
  serverId: String
  status: TaskStatus!
  total: Int!
  updatedAt: DateTime!
}

input TaskCreateInput {
  countTime: Int!
  createdAt: DateTime
  finishTime: DateTime!
  id: String
  name: String!
  priority: Int!
  serverId: String
  status: TaskStatus!
  Steamer: SteamerCreateManyWithoutTaskInput
  total: Int!
  updatedAt: DateTime
  updatedBy: String!
  user: UserCreateOneWithoutTaskInput!
}

input TaskCreateManyWithoutUserInput {
  connect: [TaskWhereUniqueInput!]
  create: [TaskCreateWithoutUserInput!]
}

input TaskCreateOneWithoutSteamerInput {
  connect: TaskWhereUniqueInput
  create: TaskCreateWithoutSteamerInput
}

input TaskCreateWithoutSteamerInput {
  countTime: Int!
  createdAt: DateTime
  finishTime: DateTime!
  id: String
  name: String!
  priority: Int!
  serverId: String
  status: TaskStatus!
  total: Int!
  updatedAt: DateTime
  updatedBy: String!
  user: UserCreateOneWithoutTaskInput!
}

input TaskCreateWithoutUserInput {
  countTime: Int!
  createdAt: DateTime
  finishTime: DateTime!
  id: String
  name: String!
  priority: Int!
  serverId: String
  status: TaskStatus!
  Steamer: SteamerCreateManyWithoutTaskInput
  total: Int!
  updatedAt: DateTime
  updatedBy: String!
}

input TaskListRelationFilter {
  every: TaskWhereInput
  none: TaskWhereInput
  some: TaskWhereInput
}

input TaskOrderByInput {
  countTime: SortOrder
  createdAt: SortOrder
  createdBy: SortOrder
  finishTime: SortOrder
  id: SortOrder
  name: SortOrder
  priority: SortOrder
  serverId: SortOrder
  status: SortOrder
  total: SortOrder
  updatedAt: SortOrder
  updatedBy: SortOrder
}

input TaskScalarWhereInput {
  AND: [TaskScalarWhereInput!]
  countTime: IntFilter
  createdAt: DateTimeFilter
  createdBy: StringFilter
  finishTime: DateTimeFilter
  id: StringFilter
  name: StringFilter
  NOT: [TaskScalarWhereInput!]
  OR: [TaskScalarWhereInput!]
  priority: IntFilter
  serverId: StringNullableFilter
  status: TaskStatus
  total: IntFilter
  updatedAt: DateTimeFilter
  updatedBy: StringFilter
}

enum TaskStatus {
  CANCELED
  COMPLETED
  ONGOING
  PENDING
  TIMEUP
}

input TaskUpdateInput {
  countTime: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  finishTime: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  priority: IntFieldUpdateOperationsInput
  serverId: NullableStringFieldUpdateOperationsInput
  status: TaskStatus
  Steamer: SteamerUpdateManyWithoutTaskInput
  total: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutTaskInput
}

input TaskUpdateManyDataInput {
  countTime: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  finishTime: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  priority: IntFieldUpdateOperationsInput
  serverId: NullableStringFieldUpdateOperationsInput
  status: TaskStatus
  total: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
}

input TaskUpdateManyWithoutUserInput {
  connect: [TaskWhereUniqueInput!]
  create: [TaskCreateWithoutUserInput!]
  delete: [TaskWhereUniqueInput!]
  deleteMany: [TaskScalarWhereInput!]
  disconnect: [TaskWhereUniqueInput!]
  set: [TaskWhereUniqueInput!]
  update: [TaskUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [TaskUpdateManyWithWhereNestedInput!]
  upsert: [TaskUpsertWithWhereUniqueWithoutUserInput!]
}

input TaskUpdateManyWithWhereNestedInput {
  data: TaskUpdateManyDataInput!
  where: TaskScalarWhereInput!
}

input TaskUpdateOneWithoutSteamerInput {
  connect: TaskWhereUniqueInput
  create: TaskCreateWithoutSteamerInput
  delete: Boolean
  disconnect: Boolean
  update: TaskUpdateWithoutSteamerDataInput
  upsert: TaskUpsertWithoutSteamerInput
}

input TaskUpdateWithoutSteamerDataInput {
  countTime: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  finishTime: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  priority: IntFieldUpdateOperationsInput
  serverId: NullableStringFieldUpdateOperationsInput
  status: TaskStatus
  total: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutTaskInput
}

input TaskUpdateWithoutUserDataInput {
  countTime: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  finishTime: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  priority: IntFieldUpdateOperationsInput
  serverId: NullableStringFieldUpdateOperationsInput
  status: TaskStatus
  Steamer: SteamerUpdateManyWithoutTaskInput
  total: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
}

input TaskUpdateWithWhereUniqueWithoutUserInput {
  data: TaskUpdateWithoutUserDataInput!
  where: TaskWhereUniqueInput!
}

input TaskUpsertWithoutSteamerInput {
  create: TaskCreateWithoutSteamerInput!
  update: TaskUpdateWithoutSteamerDataInput!
}

input TaskUpsertWithWhereUniqueWithoutUserInput {
  create: TaskCreateWithoutUserInput!
  update: TaskUpdateWithoutUserDataInput!
  where: TaskWhereUniqueInput!
}

input TaskWhereInput {
  AND: [TaskWhereInput!]
  countTime: IntFilter
  createdAt: DateTimeFilter
  createdBy: StringFilter
  finishTime: DateTimeFilter
  id: StringFilter
  name: StringFilter
  NOT: [TaskWhereInput!]
  OR: [TaskWhereInput!]
  priority: IntFilter
  serverId: StringNullableFilter
  status: TaskStatus
  Steamer: SteamerListRelationFilter
  total: IntFilter
  updatedAt: DateTimeFilter
  updatedBy: StringFilter
  user: UserWhereInput
}

input TaskWhereUniqueInput {
  createdBy: String
  id: String
}

type User {
  enableStatus: EnableStatus!
  id: String!
  name: String
  userName: String!
}

input UserCreateInput {
  createdAt: DateTime
  enableStatus: EnableStatus!
  id: String
  LogUser: LogUserCreateManyWithoutUserInput
  name: String
  password: String!
  Task: TaskCreateManyWithoutUserInput
  updatedAt: DateTime
  userName: String!
}

input UserCreateOneWithoutLogUserInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutLogUserInput
}

input UserCreateOneWithoutTaskInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTaskInput
}

input UserCreateWithoutLogUserInput {
  createdAt: DateTime
  enableStatus: EnableStatus!
  id: String
  name: String
  password: String!
  Task: TaskCreateManyWithoutUserInput
  updatedAt: DateTime
  userName: String!
}

input UserCreateWithoutTaskInput {
  createdAt: DateTime
  enableStatus: EnableStatus!
  id: String
  LogUser: LogUserCreateManyWithoutUserInput
  name: String
  password: String!
  updatedAt: DateTime
  userName: String!
}

enum UserRole {
  CASHIER
  CHEF
  NONE
}

input UserUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  enableStatus: EnableStatus
  id: StringFieldUpdateOperationsInput
  LogUser: LogUserUpdateManyWithoutUserInput
  name: NullableStringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  Task: TaskUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userName: StringFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutLogUserInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutLogUserInput
  update: UserUpdateWithoutLogUserDataInput
  upsert: UserUpsertWithoutLogUserInput
}

input UserUpdateOneRequiredWithoutTaskInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTaskInput
  update: UserUpdateWithoutTaskDataInput
  upsert: UserUpsertWithoutTaskInput
}

input UserUpdateWithoutLogUserDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  enableStatus: EnableStatus
  id: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  Task: TaskUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userName: StringFieldUpdateOperationsInput
}

input UserUpdateWithoutTaskDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  enableStatus: EnableStatus
  id: StringFieldUpdateOperationsInput
  LogUser: LogUserUpdateManyWithoutUserInput
  name: NullableStringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userName: StringFieldUpdateOperationsInput
}

input UserUpsertWithoutLogUserInput {
  create: UserCreateWithoutLogUserInput!
  update: UserUpdateWithoutLogUserDataInput!
}

input UserUpsertWithoutTaskInput {
  create: UserCreateWithoutTaskInput!
  update: UserUpdateWithoutTaskDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  createdAt: DateTimeFilter
  enableStatus: EnableStatus
  id: StringFilter
  LogUser: LogUserListRelationFilter
  name: StringNullableFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
  Task: TaskListRelationFilter
  updatedAt: DateTimeFilter
  userName: StringFilter
}

input UserWhereUniqueInput {
  id: String
  userName: String
}
