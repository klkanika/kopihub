### This file was generated by Nexus Schema
### Do not make changes to this file directly


input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

type Employee {
  createdAt: DateTime!
  earning: Float!
  faculty: String
  hiringType: HiringType!
  id: String!
  name: String!
  status: EmployeeStatus!
  university: String
  updateAt: DateTime!
}

input EmployeeCreateInput {
  createdAt: DateTime
  earning: Float!
  faculty: String
  hiringType: HiringType!
  id: String
  name: String!
  Payroll: PayrollCreateManyWithoutEmployeeInput
  status: EmployeeStatus!
  university: String
  updateAt: DateTime
  WorkingHistory: WorkingHistoryCreateManyWithoutEmployeeInput
}

input EmployeeCreateOneWithoutPayrollInput {
  connect: EmployeeWhereUniqueInput
  create: EmployeeCreateWithoutPayrollInput
}

input EmployeeCreateOneWithoutWorkingHistoryInput {
  connect: EmployeeWhereUniqueInput
  create: EmployeeCreateWithoutWorkingHistoryInput
}

input EmployeeCreateWithoutPayrollInput {
  createdAt: DateTime
  earning: Float!
  faculty: String
  hiringType: HiringType!
  id: String
  name: String!
  status: EmployeeStatus!
  university: String
  updateAt: DateTime
  WorkingHistory: WorkingHistoryCreateManyWithoutEmployeeInput
}

input EmployeeCreateWithoutWorkingHistoryInput {
  createdAt: DateTime
  earning: Float!
  faculty: String
  hiringType: HiringType!
  id: String
  name: String!
  Payroll: PayrollCreateManyWithoutEmployeeInput
  status: EmployeeStatus!
  university: String
  updateAt: DateTime
}

input EmployeeOrderByInput {
  createdAt: SortOrder
  earning: SortOrder
  faculty: SortOrder
  hiringType: SortOrder
  id: SortOrder
  name: SortOrder
  status: SortOrder
  university: SortOrder
  updateAt: SortOrder
}

enum EmployeeStatus {
  ACTIVE
  DELETED
}

input EmployeeUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  earning: FloatFieldUpdateOperationsInput
  faculty: NullableStringFieldUpdateOperationsInput
  hiringType: HiringType
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  Payroll: PayrollUpdateManyWithoutEmployeeInput
  status: EmployeeStatus
  university: NullableStringFieldUpdateOperationsInput
  updateAt: DateTimeFieldUpdateOperationsInput
  WorkingHistory: WorkingHistoryUpdateManyWithoutEmployeeInput
}

input EmployeeUpdateOneRequiredWithoutWorkingHistoryInput {
  connect: EmployeeWhereUniqueInput
  create: EmployeeCreateWithoutWorkingHistoryInput
  update: EmployeeUpdateWithoutWorkingHistoryDataInput
  upsert: EmployeeUpsertWithoutWorkingHistoryInput
}

input EmployeeUpdateWithoutWorkingHistoryDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  earning: FloatFieldUpdateOperationsInput
  faculty: NullableStringFieldUpdateOperationsInput
  hiringType: HiringType
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  Payroll: PayrollUpdateManyWithoutEmployeeInput
  status: EmployeeStatus
  university: NullableStringFieldUpdateOperationsInput
  updateAt: DateTimeFieldUpdateOperationsInput
}

input EmployeeUpsertWithoutWorkingHistoryInput {
  create: EmployeeCreateWithoutWorkingHistoryInput!
  update: EmployeeUpdateWithoutWorkingHistoryDataInput!
}

input EmployeeWhereInput {
  AND: [EmployeeWhereInput!]
  createdAt: DateTimeFilter
  earning: FloatFilter
  faculty: StringNullableFilter
  hiringType: HiringType
  id: StringFilter
  name: StringFilter
  NOT: [EmployeeWhereInput!]
  OR: [EmployeeWhereInput!]
  Payroll: PayrollListRelationFilter
  status: EmployeeStatus
  university: StringNullableFilter
  updateAt: DateTimeFilter
  WorkingHistory: WorkingHistoryListRelationFilter
}

input EmployeeWhereUniqueInput {
  id: String
}

enum EnableStatus {
  DELETE
  HIDE
  SHOW
}

input FloatFieldUpdateOperationsInput {
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

type getEmployeeHistoriesArgs {
  payrolls: [Payroll!]
  workingHistories: [WorkingHistory!]
}

type getEmployeesEarningArgs {
  data: [getEmployeesEarningRow!]
}

type getEmployeesEarningRow {
  id: String
  name: String
  remainingEarning: Float
}

type getNotificationLogArgs {
  data: [getNotificationLogRow!]
}

type getNotificationLogRow {
  createdAt: String
  id: String
  message: String
}

type getQueuesArgs {
  activeQueues: [getQueuesRow!]
  recentQueue: Queue
}

type getQueuesRow {
  createdAt: DateTime
  id: Int
  name: String
  ordered: Boolean
  pictureUrl: String
  queueNo: String
  seat: Int
  status: String
  userId: String
}

enum HiringType {
  DAILY
  HOURLY
  MONTHLY
}

input IntFieldUpdateOperationsInput {
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type LogUser {
  createdAt: DateTime!
  id: String!
  role: UserRole!
  userId: String!
}

input LogUserCreateInput {
  createdAt: DateTime
  id: String
  role: UserRole!
  user: UserCreateOneWithoutLogUserInput!
}

input LogUserCreateManyWithoutUserInput {
  connect: [LogUserWhereUniqueInput!]
  create: [LogUserCreateWithoutUserInput!]
}

input LogUserCreateWithoutUserInput {
  createdAt: DateTime
  id: String
  role: UserRole!
}

input LogUserListRelationFilter {
  every: LogUserWhereInput
  none: LogUserWhereInput
  some: LogUserWhereInput
}

input LogUserScalarWhereInput {
  AND: [LogUserScalarWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [LogUserScalarWhereInput!]
  OR: [LogUserScalarWhereInput!]
  role: UserRole
  userId: StringFilter
}

input LogUserUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  role: UserRole
  user: UserUpdateOneRequiredWithoutLogUserInput
}

input LogUserUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  role: UserRole
}

input LogUserUpdateManyWithoutUserInput {
  connect: [LogUserWhereUniqueInput!]
  create: [LogUserCreateWithoutUserInput!]
  delete: [LogUserWhereUniqueInput!]
  deleteMany: [LogUserScalarWhereInput!]
  disconnect: [LogUserWhereUniqueInput!]
  set: [LogUserWhereUniqueInput!]
  update: [LogUserUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [LogUserUpdateManyWithWhereNestedInput!]
  upsert: [LogUserUpsertWithWhereUniqueWithoutUserInput!]
}

input LogUserUpdateManyWithWhereNestedInput {
  data: LogUserUpdateManyDataInput!
  where: LogUserScalarWhereInput!
}

input LogUserUpdateWithoutUserDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  role: UserRole
}

input LogUserUpdateWithWhereUniqueWithoutUserInput {
  data: LogUserUpdateWithoutUserDataInput!
  where: LogUserWhereUniqueInput!
}

input LogUserUpsertWithWhereUniqueWithoutUserInput {
  create: LogUserCreateWithoutUserInput!
  update: LogUserUpdateWithoutUserDataInput!
  where: LogUserWhereUniqueInput!
}

input LogUserWhereInput {
  AND: [LogUserWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [LogUserWhereInput!]
  OR: [LogUserWhereInput!]
  role: UserRole
  user: UserWhereInput
  userId: StringFilter
}

input LogUserWhereUniqueInput {
  id: String
  userId: String
}

type Mutation {
  bookQueue(name: String, pictureUrl: String, seat: Int!, userId: String): Boolean
  cancelQueue(id: Int!): Boolean
  createNotification(fri: Boolean!, hour: Int!, message: String!, minute: Int!, mon: Boolean!, sat: Boolean!, sun: Boolean!, thu: Boolean!, token: String!, tue: Boolean!, userId: String!, wed: Boolean!): Notification
  createOneEmployee(data: EmployeeCreateInput!): Employee!
  createOneLogUser(data: LogUserCreateInput!): LogUser!
  createOneNotification(data: NotificationCreateInput!): Notification!
  createOneNotificationLog(data: NotificationLogCreateInput!): NotificationLog!
  createOneOTP(data: OTPCreateInput!): OTP!
  createOnePayroll(data: PayrollCreateInput!): Payroll!
  createOneSteamer(data: SteamerCreateInput!): Steamer!
  createOneTask(data: TaskCreateInput!): Task!
  createOneTaskLog(data: TaskLogCreateInput!): TaskLog!
  createOneUser(data: UserCreateInput!): User!
  createOneWorkingHistory(data: WorkingHistoryCreateInput!): WorkingHistory!
  createTask(countTime: Int!, finishTime: DateTime, name: String!, serverId: String, total: Int!, userId: String!): Task
  createUser(name: String!, password: String!, userName: String!): User
  deleteOneNotification(where: NotificationWhereUniqueInput!): Notification
  deleteOneWorkingHistory(where: WorkingHistoryWhereUniqueInput!): WorkingHistory
  fetchQueue(id: Int!, tableId: Int): Boolean
  login(password: String!, userName: String!): LogUser
  orderFood(id: Int!): Boolean
  UpdateEditTask(name: String!, taskId: String!, total: Int!): Task
  updateNotification(fri: Boolean!, hour: Int!, id: String!, message: String!, minute: Int!, mon: Boolean!, sat: Boolean!, sun: Boolean!, thu: Boolean!, token: String!, tue: Boolean!, wed: Boolean!): Notification
  updateOneEmployee(data: EmployeeUpdateInput!, where: EmployeeWhereUniqueInput!): Employee
  updateOneLogUser(data: LogUserUpdateInput!, where: LogUserWhereUniqueInput!): LogUser
  updateOneSteamer(data: SteamerUpdateInput!, where: SteamerWhereUniqueInput!): Steamer
  updateOneTask(data: TaskUpdateInput!, where: TaskWhereUniqueInput!): Task
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateOneWorkingHistory(data: WorkingHistoryUpdateInput!, where: WorkingHistoryWhereUniqueInput!): WorkingHistory
  updateSteamerComplete(taskId: String!): Boolean
  updateTaskCancel(taskId: String!): Task
  updateTaskComplete(taskId: String!, userId: String!): Boolean
  updateTaskOngoing(countTime: Int!, finishTime: DateTime, taskId: String!, userId: String!): Boolean
  updateTaskPriority(priority: Int!, taskId: String!): Task
  updateTaskTimeup(taskId: String!, userId: String!): Boolean
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Notification {
  fri: Boolean!
  hour: Int!
  id: String!
  message: String!
  minute: Int!
  mon: Boolean!
  sat: Boolean!
  sun: Boolean!
  thu: Boolean!
  token: String!
  tue: Boolean!
  wed: Boolean!
}

input NotificationCreateInput {
  fri: Boolean
  hour: Int!
  id: String
  message: String!
  minute: Int!
  mon: Boolean
  sat: Boolean
  sun: Boolean
  thu: Boolean
  token: String!
  tue: Boolean
  updatedAt: DateTime
  user: UserCreateOneWithoutNotificationInput!
  wed: Boolean
}

input NotificationCreateManyWithoutUserInput {
  connect: [NotificationWhereUniqueInput!]
  create: [NotificationCreateWithoutUserInput!]
}

input NotificationCreateWithoutUserInput {
  fri: Boolean
  hour: Int!
  id: String
  message: String!
  minute: Int!
  mon: Boolean
  sat: Boolean
  sun: Boolean
  thu: Boolean
  token: String!
  tue: Boolean
  updatedAt: DateTime
  wed: Boolean
}

input NotificationListRelationFilter {
  every: NotificationWhereInput
  none: NotificationWhereInput
  some: NotificationWhereInput
}

type NotificationLog {
  createdAt: DateTime!
  id: String!
  message: String
  notificationId: String!
}

input NotificationLogCreateInput {
  createdAt: DateTime
  id: String
  message: String
  notificationId: String!
  token: String
  user: UserCreateOneWithoutNotificationLogInput!
}

input NotificationLogCreateManyWithoutUserInput {
  connect: [NotificationLogWhereUniqueInput!]
  create: [NotificationLogCreateWithoutUserInput!]
}

input NotificationLogCreateWithoutUserInput {
  createdAt: DateTime
  id: String
  message: String
  notificationId: String!
  token: String
}

input NotificationLogListRelationFilter {
  every: NotificationLogWhereInput
  none: NotificationLogWhereInput
  some: NotificationLogWhereInput
}

input NotificationLogScalarWhereInput {
  AND: [NotificationLogScalarWhereInput!]
  createdAt: DateTimeFilter
  createdBy: StringFilter
  id: StringFilter
  message: StringNullableFilter
  NOT: [NotificationLogScalarWhereInput!]
  notificationId: StringFilter
  OR: [NotificationLogScalarWhereInput!]
  token: StringNullableFilter
}

input NotificationLogUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  message: NullableStringFieldUpdateOperationsInput
  notificationId: StringFieldUpdateOperationsInput
  token: NullableStringFieldUpdateOperationsInput
}

input NotificationLogUpdateManyWithoutUserInput {
  connect: [NotificationLogWhereUniqueInput!]
  create: [NotificationLogCreateWithoutUserInput!]
  delete: [NotificationLogWhereUniqueInput!]
  deleteMany: [NotificationLogScalarWhereInput!]
  disconnect: [NotificationLogWhereUniqueInput!]
  set: [NotificationLogWhereUniqueInput!]
  update: [NotificationLogUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [NotificationLogUpdateManyWithWhereNestedInput!]
  upsert: [NotificationLogUpsertWithWhereUniqueWithoutUserInput!]
}

input NotificationLogUpdateManyWithWhereNestedInput {
  data: NotificationLogUpdateManyDataInput!
  where: NotificationLogScalarWhereInput!
}

input NotificationLogUpdateWithoutUserDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  message: NullableStringFieldUpdateOperationsInput
  notificationId: StringFieldUpdateOperationsInput
  token: NullableStringFieldUpdateOperationsInput
}

input NotificationLogUpdateWithWhereUniqueWithoutUserInput {
  data: NotificationLogUpdateWithoutUserDataInput!
  where: NotificationLogWhereUniqueInput!
}

input NotificationLogUpsertWithWhereUniqueWithoutUserInput {
  create: NotificationLogCreateWithoutUserInput!
  update: NotificationLogUpdateWithoutUserDataInput!
  where: NotificationLogWhereUniqueInput!
}

input NotificationLogWhereInput {
  AND: [NotificationLogWhereInput!]
  createdAt: DateTimeFilter
  createdBy: StringFilter
  id: StringFilter
  message: StringNullableFilter
  NOT: [NotificationLogWhereInput!]
  notificationId: StringFilter
  OR: [NotificationLogWhereInput!]
  token: StringNullableFilter
  user: UserWhereInput
}

input NotificationLogWhereUniqueInput {
  id: String
}

input NotificationScalarWhereInput {
  AND: [NotificationScalarWhereInput!]
  fri: BoolFilter
  hour: IntFilter
  id: StringFilter
  message: StringFilter
  minute: IntFilter
  mon: BoolFilter
  NOT: [NotificationScalarWhereInput!]
  OR: [NotificationScalarWhereInput!]
  sat: BoolFilter
  sun: BoolFilter
  thu: BoolFilter
  token: StringFilter
  tue: BoolFilter
  updatedAt: DateTimeFilter
  updatedBy: StringFilter
  wed: BoolFilter
}

input NotificationUpdateManyDataInput {
  fri: BoolFieldUpdateOperationsInput
  hour: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  message: StringFieldUpdateOperationsInput
  minute: IntFieldUpdateOperationsInput
  mon: BoolFieldUpdateOperationsInput
  sat: BoolFieldUpdateOperationsInput
  sun: BoolFieldUpdateOperationsInput
  thu: BoolFieldUpdateOperationsInput
  token: StringFieldUpdateOperationsInput
  tue: BoolFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  wed: BoolFieldUpdateOperationsInput
}

input NotificationUpdateManyWithoutUserInput {
  connect: [NotificationWhereUniqueInput!]
  create: [NotificationCreateWithoutUserInput!]
  delete: [NotificationWhereUniqueInput!]
  deleteMany: [NotificationScalarWhereInput!]
  disconnect: [NotificationWhereUniqueInput!]
  set: [NotificationWhereUniqueInput!]
  update: [NotificationUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [NotificationUpdateManyWithWhereNestedInput!]
  upsert: [NotificationUpsertWithWhereUniqueWithoutUserInput!]
}

input NotificationUpdateManyWithWhereNestedInput {
  data: NotificationUpdateManyDataInput!
  where: NotificationScalarWhereInput!
}

input NotificationUpdateWithoutUserDataInput {
  fri: BoolFieldUpdateOperationsInput
  hour: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  message: StringFieldUpdateOperationsInput
  minute: IntFieldUpdateOperationsInput
  mon: BoolFieldUpdateOperationsInput
  sat: BoolFieldUpdateOperationsInput
  sun: BoolFieldUpdateOperationsInput
  thu: BoolFieldUpdateOperationsInput
  token: StringFieldUpdateOperationsInput
  tue: BoolFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  wed: BoolFieldUpdateOperationsInput
}

input NotificationUpdateWithWhereUniqueWithoutUserInput {
  data: NotificationUpdateWithoutUserDataInput!
  where: NotificationWhereUniqueInput!
}

input NotificationUpsertWithWhereUniqueWithoutUserInput {
  create: NotificationCreateWithoutUserInput!
  update: NotificationUpdateWithoutUserDataInput!
  where: NotificationWhereUniqueInput!
}

input NotificationWhereInput {
  AND: [NotificationWhereInput!]
  fri: BoolFilter
  hour: IntFilter
  id: StringFilter
  message: StringFilter
  minute: IntFilter
  mon: BoolFilter
  NOT: [NotificationWhereInput!]
  OR: [NotificationWhereInput!]
  sat: BoolFilter
  sun: BoolFilter
  thu: BoolFilter
  token: StringFilter
  tue: BoolFilter
  updatedAt: DateTimeFilter
  updatedBy: StringFilter
  user: UserWhereInput
  wed: BoolFilter
}

input NotificationWhereUniqueInput {
  id: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type OTP {
  createdAt: DateTime!
  id: String!
  message: String
  tel: String
}

input OTPCreateInput {
  createdAt: DateTime
  id: String
  message: String
  tel: String
  user: UserCreateOneWithoutOTPInput!
}

input OTPCreateManyWithoutUserInput {
  connect: [OTPWhereUniqueInput!]
  create: [OTPCreateWithoutUserInput!]
}

input OTPCreateWithoutUserInput {
  createdAt: DateTime
  id: String
  message: String
  tel: String
}

input OTPListRelationFilter {
  every: OTPWhereInput
  none: OTPWhereInput
  some: OTPWhereInput
}

input OTPScalarWhereInput {
  AND: [OTPScalarWhereInput!]
  createdAt: DateTimeFilter
  createdBy: StringFilter
  id: StringFilter
  message: StringNullableFilter
  NOT: [OTPScalarWhereInput!]
  OR: [OTPScalarWhereInput!]
  tel: StringNullableFilter
}

input OTPUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  message: NullableStringFieldUpdateOperationsInput
  tel: NullableStringFieldUpdateOperationsInput
}

input OTPUpdateManyWithoutUserInput {
  connect: [OTPWhereUniqueInput!]
  create: [OTPCreateWithoutUserInput!]
  delete: [OTPWhereUniqueInput!]
  deleteMany: [OTPScalarWhereInput!]
  disconnect: [OTPWhereUniqueInput!]
  set: [OTPWhereUniqueInput!]
  update: [OTPUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [OTPUpdateManyWithWhereNestedInput!]
  upsert: [OTPUpsertWithWhereUniqueWithoutUserInput!]
}

input OTPUpdateManyWithWhereNestedInput {
  data: OTPUpdateManyDataInput!
  where: OTPScalarWhereInput!
}

input OTPUpdateWithoutUserDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  message: NullableStringFieldUpdateOperationsInput
  tel: NullableStringFieldUpdateOperationsInput
}

input OTPUpdateWithWhereUniqueWithoutUserInput {
  data: OTPUpdateWithoutUserDataInput!
  where: OTPWhereUniqueInput!
}

input OTPUpsertWithWhereUniqueWithoutUserInput {
  create: OTPCreateWithoutUserInput!
  update: OTPUpdateWithoutUserDataInput!
  where: OTPWhereUniqueInput!
}

input OTPWhereInput {
  AND: [OTPWhereInput!]
  createdAt: DateTimeFilter
  createdBy: StringFilter
  id: StringFilter
  message: StringNullableFilter
  NOT: [OTPWhereInput!]
  OR: [OTPWhereInput!]
  tel: StringNullableFilter
  user: UserWhereInput
}

input OTPWhereUniqueInput {
  id: String
}

type Payroll {
  createdAt: DateTime!
  employee: Employee!
  employeeId: String!
  id: String!
  paid: Float!
  payrollDate: DateTime!
  updateAt: DateTime!
}

input PayrollCreateInput {
  createdAt: DateTime
  employee: EmployeeCreateOneWithoutPayrollInput!
  id: String
  paid: Float!
  payrollDate: DateTime!
  updateAt: DateTime
}

input PayrollCreateManyWithoutEmployeeInput {
  connect: [PayrollWhereUniqueInput!]
  create: [PayrollCreateWithoutEmployeeInput!]
}

input PayrollCreateWithoutEmployeeInput {
  createdAt: DateTime
  id: String
  paid: Float!
  payrollDate: DateTime!
  updateAt: DateTime
}

input PayrollListRelationFilter {
  every: PayrollWhereInput
  none: PayrollWhereInput
  some: PayrollWhereInput
}

input PayrollOrderByInput {
  createdAt: SortOrder
  employeeId: SortOrder
  id: SortOrder
  paid: SortOrder
  payrollDate: SortOrder
  updateAt: SortOrder
}

input PayrollScalarWhereInput {
  AND: [PayrollScalarWhereInput!]
  createdAt: DateTimeFilter
  employeeId: StringFilter
  id: StringFilter
  NOT: [PayrollScalarWhereInput!]
  OR: [PayrollScalarWhereInput!]
  paid: FloatFilter
  payrollDate: DateTimeFilter
  updateAt: DateTimeFilter
}

input PayrollUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  paid: FloatFieldUpdateOperationsInput
  payrollDate: DateTimeFieldUpdateOperationsInput
  updateAt: DateTimeFieldUpdateOperationsInput
}

input PayrollUpdateManyWithoutEmployeeInput {
  connect: [PayrollWhereUniqueInput!]
  create: [PayrollCreateWithoutEmployeeInput!]
  delete: [PayrollWhereUniqueInput!]
  deleteMany: [PayrollScalarWhereInput!]
  disconnect: [PayrollWhereUniqueInput!]
  set: [PayrollWhereUniqueInput!]
  update: [PayrollUpdateWithWhereUniqueWithoutEmployeeInput!]
  updateMany: [PayrollUpdateManyWithWhereNestedInput!]
  upsert: [PayrollUpsertWithWhereUniqueWithoutEmployeeInput!]
}

input PayrollUpdateManyWithWhereNestedInput {
  data: PayrollUpdateManyDataInput!
  where: PayrollScalarWhereInput!
}

input PayrollUpdateWithoutEmployeeDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  paid: FloatFieldUpdateOperationsInput
  payrollDate: DateTimeFieldUpdateOperationsInput
  updateAt: DateTimeFieldUpdateOperationsInput
}

input PayrollUpdateWithWhereUniqueWithoutEmployeeInput {
  data: PayrollUpdateWithoutEmployeeDataInput!
  where: PayrollWhereUniqueInput!
}

input PayrollUpsertWithWhereUniqueWithoutEmployeeInput {
  create: PayrollCreateWithoutEmployeeInput!
  update: PayrollUpdateWithoutEmployeeDataInput!
  where: PayrollWhereUniqueInput!
}

input PayrollWhereInput {
  AND: [PayrollWhereInput!]
  createdAt: DateTimeFilter
  employee: EmployeeWhereInput
  employeeId: StringFilter
  id: StringFilter
  NOT: [PayrollWhereInput!]
  OR: [PayrollWhereInput!]
  paid: FloatFilter
  payrollDate: DateTimeFilter
  updateAt: DateTimeFilter
}

input PayrollWhereUniqueInput {
  id: String
}

type Query {
  checkAdmin(id: String!): User
  employees(after: EmployeeWhereUniqueInput, before: EmployeeWhereUniqueInput, first: Int, last: Int, orderBy: [EmployeeOrderByInput!], where: EmployeeWhereInput): [Employee!]!
  getAllNotifyLog: getNotificationLogArgs
  getEmployeeHistories(employeeId: String!, endDate: DateTime, startDate: DateTime): getEmployeeHistoriesArgs
  getEmployeesEarning: getEmployeesEarningArgs
  getMyQueue(userId: String!): Boolean
  getNotificationById(id: String!): Notification
  getQueues: getQueuesArgs
  notificationLogs(after: NotificationLogWhereUniqueInput, before: NotificationLogWhereUniqueInput, first: Int, last: Int, where: NotificationLogWhereInput): [NotificationLog!]!
  notifications(after: NotificationWhereUniqueInput, before: NotificationWhereUniqueInput, first: Int, last: Int, where: NotificationWhereInput): [Notification!]!
  payrolls(after: PayrollWhereUniqueInput, before: PayrollWhereUniqueInput, first: Int, last: Int, orderBy: [PayrollOrderByInput!], where: PayrollWhereInput): [Payroll!]!
  queues(after: QueueWhereUniqueInput, before: QueueWhereUniqueInput, first: Int, last: Int, orderBy: [QueueOrderByInput!], where: QueueWhereInput): [Queue!]!
  steamers(after: SteamerWhereUniqueInput, before: SteamerWhereUniqueInput, first: Int, last: Int, orderBy: [SteamerOrderByInput!], where: SteamerWhereInput): [Steamer!]!
  tables(after: TableWhereUniqueInput, before: TableWhereUniqueInput, first: Int, last: Int, orderBy: [TableOrderByInput!], where: TableWhereInput): [Table!]!
  tasks(after: TaskWhereUniqueInput, before: TaskWhereUniqueInput, first: Int, last: Int, orderBy: [TaskOrderByInput!], where: TaskWhereInput): [Task!]!
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int, where: UserWhereInput): [User!]!
  workingHistories(after: WorkingHistoryWhereUniqueInput, before: WorkingHistoryWhereUniqueInput, first: Int, last: Int, orderBy: [WorkingHistoryOrderByInput!], where: WorkingHistoryWhereInput): [WorkingHistory!]!
}

type Queue {
  createdAt: DateTime!
  id: Int!
  name: String
  ordered: Boolean!
  orderedAt: DateTime
  pictureUrl: String
  queueNo: String!
  seat: Int!
  status: QueueStatus!
  table: Table
  tableId: Int
  updateAt: DateTime!
  userId: String
}

input QueueListRelationFilter {
  every: QueueWhereInput
  none: QueueWhereInput
  some: QueueWhereInput
}

input QueueOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  ordered: SortOrder
  orderedAt: SortOrder
  pictureUrl: SortOrder
  queueNo: SortOrder
  seat: SortOrder
  status: SortOrder
  tableId: SortOrder
  updateAt: SortOrder
  userId: SortOrder
}

enum QueueStatus {
  ACTIVE
  CANCELLED
  SUCCESS
}

input QueueWhereInput {
  AND: [QueueWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringNullableFilter
  NOT: [QueueWhereInput!]
  OR: [QueueWhereInput!]
  ordered: BoolFilter
  orderedAt: DateTimeNullableFilter
  pictureUrl: StringNullableFilter
  queueNo: StringFilter
  seat: IntFilter
  status: QueueStatus
  table: TableWhereInput
  tableId: IntNullableFilter
  updateAt: DateTimeFilter
  userId: StringNullableFilter
}

input QueueWhereUniqueInput {
  id: Int
}

enum SortOrder {
  asc
  desc
}

type Steamer {
  id: String!
  machineNo: Int!
  steamerNo: Int!
  Task: Task
  taskId: String
  updatedAt: DateTime!
  updatedBy: String!
}

input SteamerCreateInput {
  id: String
  machineNo: Int!
  steamerNo: Int!
  Task: TaskCreateOneWithoutSteamerInput
  updatedAt: DateTime
  updatedBy: String!
}

input SteamerCreateManyWithoutTaskInput {
  connect: [SteamerWhereUniqueInput!]
  create: [SteamerCreateWithoutTaskInput!]
}

input SteamerCreateWithoutTaskInput {
  id: String
  machineNo: Int!
  steamerNo: Int!
  updatedAt: DateTime
  updatedBy: String!
}

input SteamerListRelationFilter {
  every: SteamerWhereInput
  none: SteamerWhereInput
  some: SteamerWhereInput
}

input SteamerOrderByInput {
  id: SortOrder
  machineNo: SortOrder
  steamerNo: SortOrder
  taskId: SortOrder
  updatedAt: SortOrder
  updatedBy: SortOrder
}

input SteamerScalarWhereInput {
  AND: [SteamerScalarWhereInput!]
  id: StringFilter
  machineNo: IntFilter
  NOT: [SteamerScalarWhereInput!]
  OR: [SteamerScalarWhereInput!]
  steamerNo: IntFilter
  taskId: StringNullableFilter
  updatedAt: DateTimeFilter
  updatedBy: StringFilter
}

input SteamerUpdateInput {
  id: StringFieldUpdateOperationsInput
  machineNo: IntFieldUpdateOperationsInput
  steamerNo: IntFieldUpdateOperationsInput
  Task: TaskUpdateOneWithoutSteamerInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
}

input SteamerUpdateManyDataInput {
  id: StringFieldUpdateOperationsInput
  machineNo: IntFieldUpdateOperationsInput
  steamerNo: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
}

input SteamerUpdateManyWithoutTaskInput {
  connect: [SteamerWhereUniqueInput!]
  create: [SteamerCreateWithoutTaskInput!]
  delete: [SteamerWhereUniqueInput!]
  deleteMany: [SteamerScalarWhereInput!]
  disconnect: [SteamerWhereUniqueInput!]
  set: [SteamerWhereUniqueInput!]
  update: [SteamerUpdateWithWhereUniqueWithoutTaskInput!]
  updateMany: [SteamerUpdateManyWithWhereNestedInput!]
  upsert: [SteamerUpsertWithWhereUniqueWithoutTaskInput!]
}

input SteamerUpdateManyWithWhereNestedInput {
  data: SteamerUpdateManyDataInput!
  where: SteamerScalarWhereInput!
}

input SteamerUpdateWithoutTaskDataInput {
  id: StringFieldUpdateOperationsInput
  machineNo: IntFieldUpdateOperationsInput
  steamerNo: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
}

input SteamerUpdateWithWhereUniqueWithoutTaskInput {
  data: SteamerUpdateWithoutTaskDataInput!
  where: SteamerWhereUniqueInput!
}

input SteamerUpsertWithWhereUniqueWithoutTaskInput {
  create: SteamerCreateWithoutTaskInput!
  update: SteamerUpdateWithoutTaskDataInput!
  where: SteamerWhereUniqueInput!
}

input SteamerWhereInput {
  AND: [SteamerWhereInput!]
  id: StringFilter
  machineNo: IntFilter
  NOT: [SteamerWhereInput!]
  OR: [SteamerWhereInput!]
  steamerNo: IntFilter
  Task: TaskWhereInput
  taskId: StringNullableFilter
  updatedAt: DateTimeFilter
  updatedBy: StringFilter
}

input SteamerWhereUniqueInput {
  id: String
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Table {
  id: Int!
  ochaTableName: String!
  tableName: String!
}

input TableOrderByInput {
  id: SortOrder
  ochaTableName: SortOrder
  tableName: SortOrder
}

input TableWhereInput {
  AND: [TableWhereInput!]
  id: IntFilter
  NOT: [TableWhereInput!]
  ochaTableName: StringFilter
  OR: [TableWhereInput!]
  Queue: QueueListRelationFilter
  tableName: StringFilter
}

input TableWhereUniqueInput {
  id: Int
}

type Task {
  countTime: Int!
  finishTime: DateTime!
  id: String!
  name: String!
  priority: Int!
  serverId: String
  status: TaskStatus!
  total: Int!
  updatedAt: DateTime!
}

input TaskCreateInput {
  countTime: Int!
  createdAt: DateTime
  finishTime: DateTime!
  id: String
  name: String!
  priority: Int!
  serverId: String
  status: TaskStatus!
  Steamer: SteamerCreateManyWithoutTaskInput
  TaskLog: TaskLogCreateManyWithoutTaskInput
  total: Int!
  updatedAt: DateTime
  updatedBy: String!
  user: UserCreateOneWithoutTaskInput!
}

input TaskCreateManyWithoutUserInput {
  connect: [TaskWhereUniqueInput!]
  create: [TaskCreateWithoutUserInput!]
}

input TaskCreateOneWithoutSteamerInput {
  connect: TaskWhereUniqueInput
  create: TaskCreateWithoutSteamerInput
}

input TaskCreateOneWithoutTaskLogInput {
  connect: TaskWhereUniqueInput
  create: TaskCreateWithoutTaskLogInput
}

input TaskCreateWithoutSteamerInput {
  countTime: Int!
  createdAt: DateTime
  finishTime: DateTime!
  id: String
  name: String!
  priority: Int!
  serverId: String
  status: TaskStatus!
  TaskLog: TaskLogCreateManyWithoutTaskInput
  total: Int!
  updatedAt: DateTime
  updatedBy: String!
  user: UserCreateOneWithoutTaskInput!
}

input TaskCreateWithoutTaskLogInput {
  countTime: Int!
  createdAt: DateTime
  finishTime: DateTime!
  id: String
  name: String!
  priority: Int!
  serverId: String
  status: TaskStatus!
  Steamer: SteamerCreateManyWithoutTaskInput
  total: Int!
  updatedAt: DateTime
  updatedBy: String!
  user: UserCreateOneWithoutTaskInput!
}

input TaskCreateWithoutUserInput {
  countTime: Int!
  createdAt: DateTime
  finishTime: DateTime!
  id: String
  name: String!
  priority: Int!
  serverId: String
  status: TaskStatus!
  Steamer: SteamerCreateManyWithoutTaskInput
  TaskLog: TaskLogCreateManyWithoutTaskInput
  total: Int!
  updatedAt: DateTime
  updatedBy: String!
}

input TaskListRelationFilter {
  every: TaskWhereInput
  none: TaskWhereInput
  some: TaskWhereInput
}

type TaskLog {
  createdBy: String!
  id: String!
  status: TaskStatus!
  taskId: String!
  updateStatus: TaskStatus!
}

input TaskLogCreateInput {
  createdAt: DateTime
  id: String
  status: TaskStatus!
  task: TaskCreateOneWithoutTaskLogInput!
  updateStatus: TaskStatus!
  user: UserCreateOneWithoutTaskLogInput!
}

input TaskLogCreateManyWithoutTaskInput {
  connect: [TaskLogWhereUniqueInput!]
  create: [TaskLogCreateWithoutTaskInput!]
}

input TaskLogCreateManyWithoutUserInput {
  connect: [TaskLogWhereUniqueInput!]
  create: [TaskLogCreateWithoutUserInput!]
}

input TaskLogCreateWithoutTaskInput {
  createdAt: DateTime
  id: String
  status: TaskStatus!
  updateStatus: TaskStatus!
  user: UserCreateOneWithoutTaskLogInput!
}

input TaskLogCreateWithoutUserInput {
  createdAt: DateTime
  id: String
  status: TaskStatus!
  task: TaskCreateOneWithoutTaskLogInput!
  updateStatus: TaskStatus!
}

input TaskLogListRelationFilter {
  every: TaskLogWhereInput
  none: TaskLogWhereInput
  some: TaskLogWhereInput
}

input TaskLogScalarWhereInput {
  AND: [TaskLogScalarWhereInput!]
  createdAt: DateTimeFilter
  createdBy: StringFilter
  id: StringFilter
  NOT: [TaskLogScalarWhereInput!]
  OR: [TaskLogScalarWhereInput!]
  status: TaskStatus
  taskId: StringFilter
  updateStatus: TaskStatus
}

input TaskLogUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  status: TaskStatus
  updateStatus: TaskStatus
}

input TaskLogUpdateManyWithoutTaskInput {
  connect: [TaskLogWhereUniqueInput!]
  create: [TaskLogCreateWithoutTaskInput!]
  delete: [TaskLogWhereUniqueInput!]
  deleteMany: [TaskLogScalarWhereInput!]
  disconnect: [TaskLogWhereUniqueInput!]
  set: [TaskLogWhereUniqueInput!]
  update: [TaskLogUpdateWithWhereUniqueWithoutTaskInput!]
  updateMany: [TaskLogUpdateManyWithWhereNestedInput!]
  upsert: [TaskLogUpsertWithWhereUniqueWithoutTaskInput!]
}

input TaskLogUpdateManyWithoutUserInput {
  connect: [TaskLogWhereUniqueInput!]
  create: [TaskLogCreateWithoutUserInput!]
  delete: [TaskLogWhereUniqueInput!]
  deleteMany: [TaskLogScalarWhereInput!]
  disconnect: [TaskLogWhereUniqueInput!]
  set: [TaskLogWhereUniqueInput!]
  update: [TaskLogUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [TaskLogUpdateManyWithWhereNestedInput!]
  upsert: [TaskLogUpsertWithWhereUniqueWithoutUserInput!]
}

input TaskLogUpdateManyWithWhereNestedInput {
  data: TaskLogUpdateManyDataInput!
  where: TaskLogScalarWhereInput!
}

input TaskLogUpdateWithoutTaskDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  status: TaskStatus
  updateStatus: TaskStatus
  user: UserUpdateOneRequiredWithoutTaskLogInput
}

input TaskLogUpdateWithoutUserDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  status: TaskStatus
  task: TaskUpdateOneRequiredWithoutTaskLogInput
  updateStatus: TaskStatus
}

input TaskLogUpdateWithWhereUniqueWithoutTaskInput {
  data: TaskLogUpdateWithoutTaskDataInput!
  where: TaskLogWhereUniqueInput!
}

input TaskLogUpdateWithWhereUniqueWithoutUserInput {
  data: TaskLogUpdateWithoutUserDataInput!
  where: TaskLogWhereUniqueInput!
}

input TaskLogUpsertWithWhereUniqueWithoutTaskInput {
  create: TaskLogCreateWithoutTaskInput!
  update: TaskLogUpdateWithoutTaskDataInput!
  where: TaskLogWhereUniqueInput!
}

input TaskLogUpsertWithWhereUniqueWithoutUserInput {
  create: TaskLogCreateWithoutUserInput!
  update: TaskLogUpdateWithoutUserDataInput!
  where: TaskLogWhereUniqueInput!
}

input TaskLogWhereInput {
  AND: [TaskLogWhereInput!]
  createdAt: DateTimeFilter
  createdBy: StringFilter
  id: StringFilter
  NOT: [TaskLogWhereInput!]
  OR: [TaskLogWhereInput!]
  status: TaskStatus
  task: TaskWhereInput
  taskId: StringFilter
  updateStatus: TaskStatus
  user: UserWhereInput
}

input TaskLogWhereUniqueInput {
  id: String
}

input TaskOrderByInput {
  countTime: SortOrder
  createdAt: SortOrder
  createdBy: SortOrder
  finishTime: SortOrder
  id: SortOrder
  name: SortOrder
  priority: SortOrder
  serverId: SortOrder
  status: SortOrder
  total: SortOrder
  updatedAt: SortOrder
  updatedBy: SortOrder
}

input TaskScalarWhereInput {
  AND: [TaskScalarWhereInput!]
  countTime: IntFilter
  createdAt: DateTimeFilter
  createdBy: StringFilter
  finishTime: DateTimeFilter
  id: StringFilter
  name: StringFilter
  NOT: [TaskScalarWhereInput!]
  OR: [TaskScalarWhereInput!]
  priority: IntFilter
  serverId: StringNullableFilter
  status: TaskStatus
  total: IntFilter
  updatedAt: DateTimeFilter
  updatedBy: StringFilter
}

enum TaskStatus {
  CANCELED
  COMPLETED
  ONGOING
  PENDING
  TIMEUP
}

input TaskUpdateInput {
  countTime: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  finishTime: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  priority: IntFieldUpdateOperationsInput
  serverId: NullableStringFieldUpdateOperationsInput
  status: TaskStatus
  Steamer: SteamerUpdateManyWithoutTaskInput
  TaskLog: TaskLogUpdateManyWithoutTaskInput
  total: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutTaskInput
}

input TaskUpdateManyDataInput {
  countTime: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  finishTime: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  priority: IntFieldUpdateOperationsInput
  serverId: NullableStringFieldUpdateOperationsInput
  status: TaskStatus
  total: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
}

input TaskUpdateManyWithoutUserInput {
  connect: [TaskWhereUniqueInput!]
  create: [TaskCreateWithoutUserInput!]
  delete: [TaskWhereUniqueInput!]
  deleteMany: [TaskScalarWhereInput!]
  disconnect: [TaskWhereUniqueInput!]
  set: [TaskWhereUniqueInput!]
  update: [TaskUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [TaskUpdateManyWithWhereNestedInput!]
  upsert: [TaskUpsertWithWhereUniqueWithoutUserInput!]
}

input TaskUpdateManyWithWhereNestedInput {
  data: TaskUpdateManyDataInput!
  where: TaskScalarWhereInput!
}

input TaskUpdateOneRequiredWithoutTaskLogInput {
  connect: TaskWhereUniqueInput
  create: TaskCreateWithoutTaskLogInput
  update: TaskUpdateWithoutTaskLogDataInput
  upsert: TaskUpsertWithoutTaskLogInput
}

input TaskUpdateOneWithoutSteamerInput {
  connect: TaskWhereUniqueInput
  create: TaskCreateWithoutSteamerInput
  delete: Boolean
  disconnect: Boolean
  update: TaskUpdateWithoutSteamerDataInput
  upsert: TaskUpsertWithoutSteamerInput
}

input TaskUpdateWithoutSteamerDataInput {
  countTime: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  finishTime: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  priority: IntFieldUpdateOperationsInput
  serverId: NullableStringFieldUpdateOperationsInput
  status: TaskStatus
  TaskLog: TaskLogUpdateManyWithoutTaskInput
  total: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutTaskInput
}

input TaskUpdateWithoutTaskLogDataInput {
  countTime: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  finishTime: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  priority: IntFieldUpdateOperationsInput
  serverId: NullableStringFieldUpdateOperationsInput
  status: TaskStatus
  Steamer: SteamerUpdateManyWithoutTaskInput
  total: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutTaskInput
}

input TaskUpdateWithoutUserDataInput {
  countTime: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  finishTime: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  priority: IntFieldUpdateOperationsInput
  serverId: NullableStringFieldUpdateOperationsInput
  status: TaskStatus
  Steamer: SteamerUpdateManyWithoutTaskInput
  TaskLog: TaskLogUpdateManyWithoutTaskInput
  total: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  updatedBy: StringFieldUpdateOperationsInput
}

input TaskUpdateWithWhereUniqueWithoutUserInput {
  data: TaskUpdateWithoutUserDataInput!
  where: TaskWhereUniqueInput!
}

input TaskUpsertWithoutSteamerInput {
  create: TaskCreateWithoutSteamerInput!
  update: TaskUpdateWithoutSteamerDataInput!
}

input TaskUpsertWithoutTaskLogInput {
  create: TaskCreateWithoutTaskLogInput!
  update: TaskUpdateWithoutTaskLogDataInput!
}

input TaskUpsertWithWhereUniqueWithoutUserInput {
  create: TaskCreateWithoutUserInput!
  update: TaskUpdateWithoutUserDataInput!
  where: TaskWhereUniqueInput!
}

input TaskWhereInput {
  AND: [TaskWhereInput!]
  countTime: IntFilter
  createdAt: DateTimeFilter
  createdBy: StringFilter
  finishTime: DateTimeFilter
  id: StringFilter
  name: StringFilter
  NOT: [TaskWhereInput!]
  OR: [TaskWhereInput!]
  priority: IntFilter
  serverId: StringNullableFilter
  status: TaskStatus
  Steamer: SteamerListRelationFilter
  TaskLog: TaskLogListRelationFilter
  total: IntFilter
  updatedAt: DateTimeFilter
  updatedBy: StringFilter
  user: UserWhereInput
}

input TaskWhereUniqueInput {
  createdBy: String
  id: String
}

type User {
  enableStatus: EnableStatus!
  id: String!
  is_admin: Boolean!
  name: String
  userName: String!
}

input UserCreateInput {
  createdAt: DateTime
  enableStatus: EnableStatus!
  id: String
  is_admin: Boolean
  LogUser: LogUserCreateManyWithoutUserInput
  name: String
  Notification: NotificationCreateManyWithoutUserInput
  NotificationLog: NotificationLogCreateManyWithoutUserInput
  OTP: OTPCreateManyWithoutUserInput
  password: String!
  Task: TaskCreateManyWithoutUserInput
  TaskLog: TaskLogCreateManyWithoutUserInput
  updatedAt: DateTime
  userName: String!
}

input UserCreateOneWithoutLogUserInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutLogUserInput
}

input UserCreateOneWithoutNotificationInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutNotificationInput
}

input UserCreateOneWithoutNotificationLogInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutNotificationLogInput
}

input UserCreateOneWithoutOTPInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutOTPInput
}

input UserCreateOneWithoutTaskInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTaskInput
}

input UserCreateOneWithoutTaskLogInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTaskLogInput
}

input UserCreateWithoutLogUserInput {
  createdAt: DateTime
  enableStatus: EnableStatus!
  id: String
  is_admin: Boolean
  name: String
  Notification: NotificationCreateManyWithoutUserInput
  NotificationLog: NotificationLogCreateManyWithoutUserInput
  OTP: OTPCreateManyWithoutUserInput
  password: String!
  Task: TaskCreateManyWithoutUserInput
  TaskLog: TaskLogCreateManyWithoutUserInput
  updatedAt: DateTime
  userName: String!
}

input UserCreateWithoutNotificationInput {
  createdAt: DateTime
  enableStatus: EnableStatus!
  id: String
  is_admin: Boolean
  LogUser: LogUserCreateManyWithoutUserInput
  name: String
  NotificationLog: NotificationLogCreateManyWithoutUserInput
  OTP: OTPCreateManyWithoutUserInput
  password: String!
  Task: TaskCreateManyWithoutUserInput
  TaskLog: TaskLogCreateManyWithoutUserInput
  updatedAt: DateTime
  userName: String!
}

input UserCreateWithoutNotificationLogInput {
  createdAt: DateTime
  enableStatus: EnableStatus!
  id: String
  is_admin: Boolean
  LogUser: LogUserCreateManyWithoutUserInput
  name: String
  Notification: NotificationCreateManyWithoutUserInput
  OTP: OTPCreateManyWithoutUserInput
  password: String!
  Task: TaskCreateManyWithoutUserInput
  TaskLog: TaskLogCreateManyWithoutUserInput
  updatedAt: DateTime
  userName: String!
}

input UserCreateWithoutOTPInput {
  createdAt: DateTime
  enableStatus: EnableStatus!
  id: String
  is_admin: Boolean
  LogUser: LogUserCreateManyWithoutUserInput
  name: String
  Notification: NotificationCreateManyWithoutUserInput
  NotificationLog: NotificationLogCreateManyWithoutUserInput
  password: String!
  Task: TaskCreateManyWithoutUserInput
  TaskLog: TaskLogCreateManyWithoutUserInput
  updatedAt: DateTime
  userName: String!
}

input UserCreateWithoutTaskInput {
  createdAt: DateTime
  enableStatus: EnableStatus!
  id: String
  is_admin: Boolean
  LogUser: LogUserCreateManyWithoutUserInput
  name: String
  Notification: NotificationCreateManyWithoutUserInput
  NotificationLog: NotificationLogCreateManyWithoutUserInput
  OTP: OTPCreateManyWithoutUserInput
  password: String!
  TaskLog: TaskLogCreateManyWithoutUserInput
  updatedAt: DateTime
  userName: String!
}

input UserCreateWithoutTaskLogInput {
  createdAt: DateTime
  enableStatus: EnableStatus!
  id: String
  is_admin: Boolean
  LogUser: LogUserCreateManyWithoutUserInput
  name: String
  Notification: NotificationCreateManyWithoutUserInput
  NotificationLog: NotificationLogCreateManyWithoutUserInput
  OTP: OTPCreateManyWithoutUserInput
  password: String!
  Task: TaskCreateManyWithoutUserInput
  updatedAt: DateTime
  userName: String!
}

enum UserRole {
  CASHIER
  CHEF
  NONE
}

input UserUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  enableStatus: EnableStatus
  id: StringFieldUpdateOperationsInput
  is_admin: BoolFieldUpdateOperationsInput
  LogUser: LogUserUpdateManyWithoutUserInput
  name: NullableStringFieldUpdateOperationsInput
  Notification: NotificationUpdateManyWithoutUserInput
  NotificationLog: NotificationLogUpdateManyWithoutUserInput
  OTP: OTPUpdateManyWithoutUserInput
  password: StringFieldUpdateOperationsInput
  Task: TaskUpdateManyWithoutUserInput
  TaskLog: TaskLogUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userName: StringFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutLogUserInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutLogUserInput
  update: UserUpdateWithoutLogUserDataInput
  upsert: UserUpsertWithoutLogUserInput
}

input UserUpdateOneRequiredWithoutTaskInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTaskInput
  update: UserUpdateWithoutTaskDataInput
  upsert: UserUpsertWithoutTaskInput
}

input UserUpdateOneRequiredWithoutTaskLogInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTaskLogInput
  update: UserUpdateWithoutTaskLogDataInput
  upsert: UserUpsertWithoutTaskLogInput
}

input UserUpdateWithoutLogUserDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  enableStatus: EnableStatus
  id: StringFieldUpdateOperationsInput
  is_admin: BoolFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  Notification: NotificationUpdateManyWithoutUserInput
  NotificationLog: NotificationLogUpdateManyWithoutUserInput
  OTP: OTPUpdateManyWithoutUserInput
  password: StringFieldUpdateOperationsInput
  Task: TaskUpdateManyWithoutUserInput
  TaskLog: TaskLogUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userName: StringFieldUpdateOperationsInput
}

input UserUpdateWithoutTaskDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  enableStatus: EnableStatus
  id: StringFieldUpdateOperationsInput
  is_admin: BoolFieldUpdateOperationsInput
  LogUser: LogUserUpdateManyWithoutUserInput
  name: NullableStringFieldUpdateOperationsInput
  Notification: NotificationUpdateManyWithoutUserInput
  NotificationLog: NotificationLogUpdateManyWithoutUserInput
  OTP: OTPUpdateManyWithoutUserInput
  password: StringFieldUpdateOperationsInput
  TaskLog: TaskLogUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userName: StringFieldUpdateOperationsInput
}

input UserUpdateWithoutTaskLogDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  enableStatus: EnableStatus
  id: StringFieldUpdateOperationsInput
  is_admin: BoolFieldUpdateOperationsInput
  LogUser: LogUserUpdateManyWithoutUserInput
  name: NullableStringFieldUpdateOperationsInput
  Notification: NotificationUpdateManyWithoutUserInput
  NotificationLog: NotificationLogUpdateManyWithoutUserInput
  OTP: OTPUpdateManyWithoutUserInput
  password: StringFieldUpdateOperationsInput
  Task: TaskUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userName: StringFieldUpdateOperationsInput
}

input UserUpsertWithoutLogUserInput {
  create: UserCreateWithoutLogUserInput!
  update: UserUpdateWithoutLogUserDataInput!
}

input UserUpsertWithoutTaskInput {
  create: UserCreateWithoutTaskInput!
  update: UserUpdateWithoutTaskDataInput!
}

input UserUpsertWithoutTaskLogInput {
  create: UserCreateWithoutTaskLogInput!
  update: UserUpdateWithoutTaskLogDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  createdAt: DateTimeFilter
  enableStatus: EnableStatus
  id: StringFilter
  is_admin: BoolFilter
  LogUser: LogUserListRelationFilter
  name: StringNullableFilter
  NOT: [UserWhereInput!]
  Notification: NotificationListRelationFilter
  NotificationLog: NotificationLogListRelationFilter
  OR: [UserWhereInput!]
  OTP: OTPListRelationFilter
  password: StringFilter
  Task: TaskListRelationFilter
  TaskLog: TaskLogListRelationFilter
  updatedAt: DateTimeFilter
  userName: StringFilter
}

input UserWhereUniqueInput {
  id: String
  userName: String
}

type WorkingHistory {
  createdAt: DateTime!
  earning: Float!
  earningRate: Float!
  employee: Employee!
  employeeId: String!
  hiringType: HiringType!
  historyDate: DateTime!
  hours: Float!
  id: String!
  updateAt: DateTime!
}

input WorkingHistoryCreateInput {
  createdAt: DateTime
  earning: Float!
  earningRate: Float!
  employee: EmployeeCreateOneWithoutWorkingHistoryInput!
  hiringType: HiringType!
  historyDate: DateTime!
  hours: Float!
  id: String
  updateAt: DateTime
}

input WorkingHistoryCreateManyWithoutEmployeeInput {
  connect: [WorkingHistoryWhereUniqueInput!]
  create: [WorkingHistoryCreateWithoutEmployeeInput!]
}

input WorkingHistoryCreateWithoutEmployeeInput {
  createdAt: DateTime
  earning: Float!
  earningRate: Float!
  hiringType: HiringType!
  historyDate: DateTime!
  hours: Float!
  id: String
  updateAt: DateTime
}

input WorkingHistoryListRelationFilter {
  every: WorkingHistoryWhereInput
  none: WorkingHistoryWhereInput
  some: WorkingHistoryWhereInput
}

input WorkingHistoryOrderByInput {
  createdAt: SortOrder
  earning: SortOrder
  earningRate: SortOrder
  employeeId: SortOrder
  hiringType: SortOrder
  historyDate: SortOrder
  hours: SortOrder
  id: SortOrder
  updateAt: SortOrder
}

input WorkingHistoryScalarWhereInput {
  AND: [WorkingHistoryScalarWhereInput!]
  createdAt: DateTimeFilter
  earning: FloatFilter
  earningRate: FloatFilter
  employeeId: StringFilter
  hiringType: HiringType
  historyDate: DateTimeFilter
  hours: FloatFilter
  id: StringFilter
  NOT: [WorkingHistoryScalarWhereInput!]
  OR: [WorkingHistoryScalarWhereInput!]
  updateAt: DateTimeFilter
}

input WorkingHistoryUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  earning: FloatFieldUpdateOperationsInput
  earningRate: FloatFieldUpdateOperationsInput
  employee: EmployeeUpdateOneRequiredWithoutWorkingHistoryInput
  hiringType: HiringType
  historyDate: DateTimeFieldUpdateOperationsInput
  hours: FloatFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  updateAt: DateTimeFieldUpdateOperationsInput
}

input WorkingHistoryUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  earning: FloatFieldUpdateOperationsInput
  earningRate: FloatFieldUpdateOperationsInput
  hiringType: HiringType
  historyDate: DateTimeFieldUpdateOperationsInput
  hours: FloatFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  updateAt: DateTimeFieldUpdateOperationsInput
}

input WorkingHistoryUpdateManyWithoutEmployeeInput {
  connect: [WorkingHistoryWhereUniqueInput!]
  create: [WorkingHistoryCreateWithoutEmployeeInput!]
  delete: [WorkingHistoryWhereUniqueInput!]
  deleteMany: [WorkingHistoryScalarWhereInput!]
  disconnect: [WorkingHistoryWhereUniqueInput!]
  set: [WorkingHistoryWhereUniqueInput!]
  update: [WorkingHistoryUpdateWithWhereUniqueWithoutEmployeeInput!]
  updateMany: [WorkingHistoryUpdateManyWithWhereNestedInput!]
  upsert: [WorkingHistoryUpsertWithWhereUniqueWithoutEmployeeInput!]
}

input WorkingHistoryUpdateManyWithWhereNestedInput {
  data: WorkingHistoryUpdateManyDataInput!
  where: WorkingHistoryScalarWhereInput!
}

input WorkingHistoryUpdateWithoutEmployeeDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  earning: FloatFieldUpdateOperationsInput
  earningRate: FloatFieldUpdateOperationsInput
  hiringType: HiringType
  historyDate: DateTimeFieldUpdateOperationsInput
  hours: FloatFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  updateAt: DateTimeFieldUpdateOperationsInput
}

input WorkingHistoryUpdateWithWhereUniqueWithoutEmployeeInput {
  data: WorkingHistoryUpdateWithoutEmployeeDataInput!
  where: WorkingHistoryWhereUniqueInput!
}

input WorkingHistoryUpsertWithWhereUniqueWithoutEmployeeInput {
  create: WorkingHistoryCreateWithoutEmployeeInput!
  update: WorkingHistoryUpdateWithoutEmployeeDataInput!
  where: WorkingHistoryWhereUniqueInput!
}

input WorkingHistoryWhereInput {
  AND: [WorkingHistoryWhereInput!]
  createdAt: DateTimeFilter
  earning: FloatFilter
  earningRate: FloatFilter
  employee: EmployeeWhereInput
  employeeId: StringFilter
  hiringType: HiringType
  historyDate: DateTimeFilter
  hours: FloatFilter
  id: StringFilter
  NOT: [WorkingHistoryWhereInput!]
  OR: [WorkingHistoryWhereInput!]
  updateAt: DateTimeFilter
}

input WorkingHistoryWhereUniqueInput {
  id: String
}
